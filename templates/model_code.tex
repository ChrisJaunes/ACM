\documentclass[10pt]{ctexart}
\usepackage{listings}
\usepackage{amsmath} 
\usepackage{amssymb} 
\usepackage{xcolor}
\usepackage{xeCJK}
\usepackage{fontspec}
\usepackage{titlesec}
\usepackage{titletoc}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage[T1]{fontenc}  
\usepackage{textcomp}  
\usepackage{lmodern}
\usepackage[colorlinks,
            linkcolor=black,
            anchorcolor=black,
            citecolor=black]{hyperref}
\geometry{a4paper,scale=0.8}
\renewcommand\contentsname{Contents}
\setmonofont[Mapping={}]{Consolas} 
\setlength{\parindent}{0pt}
%\setmonofont[Mapping={}]{Consolas}    %英文引号之类的正常显示，相当于设置英文字体
%\setsansfont{Consolas} %设置英文字体 Monaco, Consolas,  Fantasque Sans Mono
%\setmainfont{Monaco} %设置英文字体
%\setmainfont{Helvetica Neue} %设置英文字体
% 定义可能使用到的颜色
%\setmainfont[BoldFont=SimHei]{SimSun}
\definecolor{CPPLight}  {HTML} {686868}
\definecolor{CPPSteel}  {HTML} {888888}
\definecolor{CPPDark}   {HTML} {262626}
\definecolor{CPPBlue}   {HTML} {4172A3}
\definecolor{CPPGreen}  {HTML} {487818}
\definecolor{CPPBrown}  {HTML} {A07040}
\definecolor{CPPRed}    {HTML} {AD4D3A}
\definecolor{CPPViolet} {HTML} {7040A0}
\definecolor{CPPGray}  {HTML} {B8B8B8}
\lstset{
    columns=fixed,       
    numbers=left,                                        % 在左侧显示行号
    frame=none,                                          % 不显示背景边框
    backgroundcolor=\color[RGB]{245,245,244},            % 设定背景颜色
    keywordstyle=\color[RGB]{40,40,255},                 % 设定关键字颜色
    numberstyle=\small\color{darkgray},                  % 设定行号格式
    commentstyle=\it\color[RGB]{0,96,96},                % 设置代码注释的格式
    stringstyle=\rmfamily\slshape\color[RGB]{128,0,0},   % 设置字符串格式
    showstringspaces=false,                              % 不显示字符串中的空格
    language=c++,                                        % 设置语言
    morekeywords={alignas,continute,friend,register,true,alignof,decltype,goto,
    reinterpret_cast,try,asm,defult,if,return,typedef,auto,delete,inline,short,
    typeid,bool,do,int,signed,typename,break,double,long,sizeof,union,case,
    dynamic_cast,mutable,static,unsigned,catch,else,namespace,static_assert,using,
    char,enum,new,static_cast,virtual,char16_t,char32_t,explict,noexcept,struct,
    void,export,nullptr,switch,volatile,class,extern,operator,template,wchar_t,
    const,false,private,this,while,constexpr,float,protected,thread_local,
    const_cast,for,public,throw,std},
    emph={map,set,multimap,multiset,unordered_map,unordered_set,
    unordered_multiset,unordered_multimap,vector,string,list,deque,
    array,stack,forwared_list,iostream,memory,shared_ptr,unique_ptr,
    random,bitset,ostream,istream,cout,cin,endl,move,default_random_engine,
    uniform_int_distribution,iterator,algorithm,functional,bing,numeric,},
    emphstyle=\color{CPPViolet},
    basicstyle=\linespread{1}\small\fontspec{Courier New Bold}\ttfamily,
    breaklines=true,
    %xleftmargin=1em,xrightmargin=1em, aboveskip=1em,
    % in the listings package configuration, try:  
    literate={"}{\textquotedbl}1,  
    tabsize=4, keepspaces=true
}
%\setmainfont{Courier New Bold}
%\begin{lstlisting}

%\end{lstlisting}
\CTEXoptions[today=old]
\title{MODEL}
\author{}
\date{Last build at \today}

\begin{document}{
\begin{titlepage}
    \centering
    \vspace{2cm}
    {\scshape\Large South China University of Technology \par}
    \vspace{1cm}
    {\scshape\Large SCUT\_gugugu\par}
    \vspace{1.5cm}
    {\Huge\bfseries MODEL\par}
    \vspace{4.5cm}
    \includegraphics[width=0.5\textwidth]{./LOGO}\par\vspace{1cm}
    %\vspace{5cm}
    %{\Large\itshape Nickwzk\par}

    \vfill

% Bottom of the page
    {\large Last build at \today\par}

%\setcounter{page}{0}
\thispagestyle{empty}
%\newpage
\end{titlepage}
\tableofcontents
\newpage
\section{Graph Theory}
\subsection{Shortest Path}

\subsection{Network Flow}
修订稿 Created By ChrisJaunes
最大权闭合子图建模 eg: (+++) - (---) \\
定义：在一个有向图中，每个点都有一个点权。闭合子图：对于这个子图，它任意一个点的的后继必须在这个子图中。最大权闭合子图：在所有的闭合子图中，该图的点权和最大。\\
建模：\\
1. 建立超级源S和超级汇T\\
2. 把所有点权为正的点与S连接一条有向边，方向是从S到u，边权是点权；把所有点权为负的点与T连接一条有向边，方向是从u到T，边权是点权的相反数；\\
3. 原图中所有有向边的边权是INT\_MAX；也可以根据情况按照割的思想处理。\\ 
答案：最大权闭合子图的权值和就是所有点的点权和-该生成图的最小割\\
\\
独立集: 一个点集，点集中的各点没有关系。\\
最大独立集: 点的个数最多的独立集。 \\
求解一般无向图的最大团、最大独立集是NPC问题。\\
二分图最大独立集 = 点的总数 - 最小点覆盖。\\
最大点权独立集的点权和 = 所有点权和-最小点权覆盖的点权\\
路径覆盖：给定有向图 G=(V,E)。设 P 是 G 的一个简单路(顶点不相交)的集合。如果 V 中每个定点恰好在P的一条路上，则称 P 是 G 的一个路径覆盖。\\
最小路径覆盖：G 的最小路径覆盖是 G 所含路径条数最少的路径覆盖\\
建模：拆点，对于原图的(u,v),连接(u->v')\\
答案：原图的结点数-新图的最大匹配数\\
\\
最小割的可行边和必须边(所有割集的交集和并集) \\
注意：必须边⊆可行边.\\
1. 残余网络中有剩余流量的边一定不在最小割中\\
2. 残余网络中一条满流边的首尾还能相互到达，那么这条边不是可行边\\
3. 残余网络中一条满流的首尾分别与S和T在一个强连通分量中，那么这条边为必须边\\
具体实现,需要先跑最大流,然后Tarjan缩强连通分量,条件是:\\
可行边 : 两端不在一个强连通分量内。\\
必须边 : 一端在S的分量内,另一端在T的分量内。\\
必须边对于小规模也可以强行割去然后跑流判断流是否减少，暴力对费用流必须边同样适用\\
\\
求割边最少的最小割:把边的权值全部乘以一个较大的数E再加1, E要严格大于边的数量\\
最小割: ans/E;\\
最小割下的最小割边: ans \% E\\
公平分配模型：\\
题意：n个球队，已经有一些胜负场，现在还有一些场次，你去分配胜负，问每支球队有没有可能获胜\\
解：\\
1. 枚举每一个人，贪心计算比赛最大获胜次数max\_win\\
2. 将比赛当作节点，从源到比赛连比赛次数边\\
3. 分配比赛胜利者，从比赛到人连无穷边\\
4. 从人到汇连{max\_win - 已经获胜的比赛次数}的边\\
5. 检查是否能将比赛全部安排完\\
\\
混合图重定向为欧拉回路\\
1. 将所有的无向边随便定向，计算得到每个点的出度与入度之差deg\\
2. 建立源点汇点S,T\\
3. 对于deg>0的点v，连一条边S→u, 流为deg/2;\\
4. 对于deg<0的点u，连一条边u→T，流为-deg/2;\\
5. 对于有向边，忽略；对于无向边(u,v)，连(u,v,1)\\
5. 判断是否能跑满流\\
\\
费用流：物品通过代价重复使用\\
1. 拆点，使用物品前和使用物品后\\
2. 对于节点[使用物品前]：考虑物品来源:源点{购买能力、购买费用}、节点[使用物品后]{INF、购买费用}; 去向:汇点{使用量、0}\\
3. 对于节点[使用物品后]：考虑物品来源:源点{使用量、0}，去向:节点[使用物品前]\\
\\
费用流：物品通过代价延后销售\\
1. 拆点，生产物品和出售物品\\
2. 对于节点[生产物品]：考虑物品来源:源点{生产能力、 生产费用}; 去向: 节点[出售物品]{INF、保存的代价}\\
3. 对于节点[出售物品]：考虑物品来源:通过节点生产物品，去向:汇点{销售能力、销售费用}\\
\\
费用流：n个点m条带权有向边的图，要给边染色，染色的边形成若干个回路且每个点都恰好属于其中k个回路。问最少要染多少边权和的路。\\
一个回路里面各个点的入度=出度=1，各个点如果都恰好属于k个回路那么各个点的入度=出度=k。\\
这样就考虑用最小费用最大流了：\\
1. 所有点u拆成两点u和u'，分别代表出度和入度\\
2. 原点向u连容量k费用0的边，u'向汇点连容量k费用0的边\\
3. 所有有向边<u,v>，u向v'连容量1费用边权的边\\
4. 这样跑最小费用最大流，如果最大流等于n*k，也就是说各个点的出度=入度=k，那么就有解，最小费用就是最小的解\\
\\
费用流：费用不是线性关系\\
费用为 $a * x^2$ : 拆边，拆成 a * 1, a * 3, a * 5, ...\\
费用为 之前的等待时间 + a : 反向考虑，倒数第i个点对整体贡献为 a * i, 拆点，拆成a, a*2, a*3, ...\\
\\
费用流：平面上给定一些黑点白点，要求一个黑点连接一个白点，并且所有线段都不相交\\
合法情况的连线，总长度明显比不合法情况的小， 题意可以转化为求让每条线段的长度和最小的方案\\
1、建立超级源超级汇\\
2、从超级源向左侧点连流量为1，费用为0的边\\
3、从左侧点向右侧点连流量为1，费用为两点欧几里得距离的边\\
4、从右侧点向超级汇连流量为1，费用为0的边\\
5、跑最小费用最大流\\
\\
区间k覆盖问题：给定n个带权开区间，区间最多可以选一次，要求保证实轴上的所有数被选择的次数要小于k次，问最大的权值。\\
1. 建立超级源超级汇\\
2. 源点向第一个点连一条容量为k、费用为0的边\\
3. 相邻节点连上用容量为k费用为0的边\\
4. 最后一个点向超级汇连一条容量为k、费用为0的边\\
5. 区间的两个端点之间连接一条容量为1的，费用为w的边\\
\\
区间至少ai覆盖问题\\
1. 建立超级源超级汇\\
2. 源点向第一个点连一条容量为INF、费用为0的边\\
3. 相邻节点连上用容量为INF-ai费用为0的边\\
4. 最后一个点向超级汇连一条容量为INF、费用为0的边\\
5. 区间的两个端点之间连接一条容量为INF的，费用为c的边\\
\\
分治优化建图\\
1. 费用为|ai-aj|可以利用差分性质通过累积权值之间的差值实现费用的绝对值\\
这样可以采用分治方式将边的数量从n*n将为n*logn\\
2. 一个点向一个区间的每一个点连边，可以利用线段树转为每个点最多向log个虚点连边\\
线段树上的点向孩子节点连边{INF}，叶子节点向孩子连边{INF}
\subsection{Tree Related}
\subsubsection{Kruskal重构树}
构造\\

除了连边，其他过程都和 $\text{Kruskal}$ 最小生成树算法完全一样。\\
当我们需要在 $u,v$ 之间连一条权值为 $w$ 的边时，$\text{Kruskal}$ 重构树算法是这样实现的：\\
新建节点 $x$，将 $x$ 的点权设为 $w$。\\
设 $u,v$ 所属集合分别为 $S_u$ 和 $S_v$，那么连边 $(x,S_u)$ 和 $(x,S_v)$，此处连有向边即可，注意没有边权！\\
将 $u$ 和 $v$ 所属集合都改为 $x$。\\
其余过程直接套用 $\text{Kruskal}$ 即可！\\
重构树的根应该为 $2n-1$，也就是最后一个点。原因为：如果以 $1\sim n$ 中的任何一个点作为根会破坏重构树的形态；连边时向下连边，只有以 $2n-1$ 为根时才能遍历整棵树。\\

性质\\

最后形成一棵有 $2n-1$ 个节点的树。\\
我们需要将 $n$ 个原来的点最后放到同一个集合中，那么需要进行 $n-1$ 次合并。每次合并都会新建 $1$ 个节点和 $2$ 条无向边。那么一共会有 $2n-1$ 个点和 $2n-2$ 条边。\\
重构树中的叶子节点为原树中的节点，其余每个节点代表了一条边。\\
我们每次将 $x$ 和下方的 $u,v$ 连边，这个证明很显然吧！\\
原树 $u$ 到 $v$ 路径上的边权最大值为重构树上 $u$ 和 $v$ 的 $\text{LCA}$ 的点权。\\
根据 $\text{Kruskal}$ 的过程，我们把边按照权值从小到大排序，那么对于所有非叶子节点，它的点权（原图的边权）一定不大于父亲节点的点权，所以路径上的最大值即为 $\text{LCA}$ 的点权。\\

Example: bzoj3551Peaks加强版 \\
有N座山峰，每座山峰有他的高度$h_i$。有些山峰之间有双向道路相连，共M条路径，每条路径有一个困难值，这个值越大表示越难走，现在有Q组询问，每组询问询问从点v开始只经过困难值小于等于x的路径所能到达的山峰中第k高的山峰，如果无解输出-1。强制在线
\begin{lstlisting}
// 3551Peaks加强版.cpp
#include <bits/stdc++.h>
using namespace std;
inline int read() {
    int x = 0, ch = getchar(); bool fg = 1;
    while(ch < '0' || ch > '9') { if(ch == '-') fg = 0; ch = getchar(); } 
    while(ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
    return fg ? x : -x;
}
typedef pair<int, int> P;
const int MAXN = 2e5 + 5, S = 17;
const int MAXE = 5e5 + 5;
pair<int, P> e[MAXE];
vector<int> G[MAXN];
inline void addEdge(int u, int v) {
    G[u].push_back(v);
}
namespace uset{
    vector<int> fa(MAXN);
    void init(int n) {
        for(int i = 0; i <= n; i++) fa[i] = i;
    }
    int Find(int x) { return fa[x] == x ? x : fa[x] = Find(fa[x]); }
    void unite(int x, int y, int z) {
        fa[Find(x)] = z;
        fa[Find(y)] = z;
    }
}
int fa[MAXN][21], val[MAXN], h[MAXN];
namespace Tree {
    struct Node {
        int l, r, s;
    }t[MAXN * 40];
    int cnt;
    vector<int>rt(MAXN, 0);
    void update(int pre, int &x, int L, int R, int v) {
        t[x = ++cnt] = t[pre]; t[x].s++;
        if(L == R) return;
        int mid = (L + R) >> 1;
        if(v <= mid) update(t[pre].l, t[x].l, L, mid, v);
        else update(t[pre].r, t[x].r, mid + 1, R, v);
    }
    int query(int x, int y, int L, int R, int k) {
        if(L == R) return L;
        if(t[y].s - t[x].s < k) return -1;
        int mid = (L + R) >> 1;
        int sum = t[t[y].r].s - t[t[x].r].s;
        if(sum >= k) return query(t[x].r, t[y].r, mid + 1, R, k);
        return query(t[x].l, t[y].l, L, mid, k - sum);
    }
}
int num[MAXN], cnt_num;
int last[MAXN], dfs_val[MAXN];
void dfs(int x) {
    dfs_val[num[x] = ++cnt_num] = h[x];
    for(auto y : G[x]) {
        dfs(y);
    }
    last[x] = cnt_num;
}
int up(int x, int y) {
    for(int i = S; i >= 0; i--) {
        if(fa[x][i] && val[fa[x][i]] <= y) x = fa[x][i];
    }
    return x;
}
int main() {
    int n = read(), m = read(), Q = read();
    uset::init(n << 1);
    for(int i = 1; i <= n; i++) cin >> h[i];
    for(int i = 1, u, v, w; i <= m; i++) {
        u = read(), v = read(), w = read();
        e[i] = make_pair(w, P(u, v));
    }
    sort(e + 1, e + m + 1);
    for(int i = 1, x, y; i <= m; i++) {
        P cur = e[i].second;
        if((x = uset::Find(cur.first)) == (y = uset::Find(cur.second))) continue;
        val[++n] = e[i].first;
        fa[x][0] = fa[y][0] = n;
        uset::unite(x, y, n);
        addEdge(n, x); addEdge(n, y);
    }
    for(int k = 1; k <= S; k++) {
        for(int i = 1; i <= n; i++) {
            fa[i][k] = fa[fa[i][k - 1]][k - 1];
        }
    }
    dfs(n);
    for(int i = 1; i <= cnt_num; i++) Tree::update(Tree::rt[i - 1], Tree::rt[i], 0, 1e9 + 1, dfs_val[i]);
    int a, b, c, ans = -1;
    while(Q--) {
        a = read(), b = read(), c = read();
        if(~ans) {
            a ^= ans; b ^= ans; c ^= ans;
        }
        int root = up(a, b);
        ans = Tree::query(Tree::rt[num[root] - 1], Tree::rt[last[root]], 0, 1e9 + 1, c);
        if(!ans || ans == 1e9 + 1) ans = -1;
        printf("%d\n", ans);
    }
    return 0;
}
\end{lstlisting}

\subsubsection{Tree Divide and Conquer}
Example: poj1741 tree \\
给一颗n个节点的树，每条边上有一个距离v（v<=1000）。定义d(u,v)为u到v的最小距离。给定k值，求有多少点对（u，v）使u到v的距离小于等于k。数据范围：$n<=10000,k<2^{31}$ \\
解：\\
这个点延伸出的几棵子树各做一次dfs，记录子树中出现的距离值，对于一棵树的距离值数组，把它排序求一次ans1，再对每棵子树分别求一个自己对自己的ans2，$ans1-\sum ans2$ 即为最后的ans。\\
\begin{lstlisting}
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int MAXN = 10003;
struct Edge {
    int to, nxt, w;
    Edge() {}
    Edge(int _to, int _nxt, int _w):to(_to), nxt(_nxt), w(_w) {}
}e[MAXN << 1];
int h[MAXN], p;
int sz[MAXN];
bool vis[MAXN];
int dep[MAXN], cnt, d[MAXN];
int n, k, ans;
inline void add_edge(int u, int v, int w) {
    e[++p] = Edge(v, h[u], w); h[u] = p;
    e[++p] = Edge(u, h[v], w); h[v] = p;
}
int getsz(int x, int fa) {
    sz[x] = 1;
    for(int i = h[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if(vis[y] || y == fa) continue;
        sz[x] += getsz(y, x);
    }
    return sz[x];
}
int getrt(int x) {
    int tot = getsz(x, 0) / 2;
    while(1) {
        int u = -1;
        for(int i = h[x]; i; i = e[i].nxt) {
            int y = e[i].to;
            if(vis[y] || sz[y] > sz[x]) continue;
            if(u == -1 || sz[y] > sz[u]) u = y;
        }
        if(~u && sz[u] > tot) x = u;
        else break;
    }
    return x;
}
void getdep(int x, int fa) {
    dep[++cnt] = d[x];
    for(int i = h[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if(vis[y] || y == fa) continue;
        d[y] = d[x] + e[i].w;
        getdep(y, x);
    }
}
int cal(int x, int v) {
    d[x] = v; cnt = 0;
    getdep(x, 0);
    sort(dep + 1, dep + cnt + 1);
    int l = 1, r = cnt, res = 0;
    while(l < r) {
        if(dep[l] + dep[r] <= k) res += r - l, l++;
        else r--;
    }
    return res;
}
void solve(int x) {
    vis[x] = 1;
    ans += cal(x, 0);
    for(int i = h[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if(vis[y]) continue;
        ans -= cal(y, e[i].w);
        solve(getrt(y));
    }
}
inline void init() {
    memset(h, 0, sizeof(h)); p = 0;
    memset(vis, 0, sizeof(vis));
    ans = 0;
}
int main() {
    while(scanf("%d%d", &n, &k) && (n || k)) {
        init();
        for(int i = 1, u, v, w; i < n; i++) {
            scanf("%d%d%d", &u, &v, &w);
            add_edge(u, v, w);
        }
        solve(getrt(1));
        printf("%d\n", ans);
    }
    return 0;
}
\end{lstlisting}

Example:bzoj2152 聪聪可可\\
由爸爸在纸上画n个“点”，并用n-1条“边”把这n个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随即选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是3的倍数，则判聪聪赢，否则可可赢。聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。\\
解：\\
与上一题类似，在计算路径长度时对3取模，用t[0],t[1],t[2]分别记录模为0、1、2的情况，那么显然答案就是t[1]*t[2]*2+t[0]*t[0]
\begin{lstlisting}
#include <cstdio>
#include <algorithm>
using namespace std;
const int MAXN = 20003;
struct Edge {
    int to, nxt, w;
    Edge() {}
    Edge(int _to, int _nxt, int _w):to(_to), nxt(_nxt), w(_w) {}
}e[MAXN << 1];
int h[MAXN], p;
int sz[MAXN];
int d[MAXN], t[5], ans;
bool vis[MAXN];
inline void add_edge(int u, int v, int w) {
    e[++p] = Edge(v, h[u], w); h[u] = p;
    e[++p] = Edge(u, h[v], w); h[v] = p;
}
int getsz(int x, int fa) {
    sz[x] = 1;
    for(int i = h[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if(vis[y] || y == fa) continue;
        sz[x] += getsz(y, x);
    }
    return sz[x];
}
int getrt(int x) {
    int tot = getsz(x, 0) / 2;
    while(1) {
        int u = -1;
        for(int i = h[x]; i; i = e[i].nxt) {
            int y = e[i].to;
            if(vis[y] || sz[y] > sz[x]) continue;
            if(u == -1 || sz[y] > sz[u]) u = y;
        }
        if(~u && sz[u] > tot) x = u;
        else break;
    }
    return x;
}
void getdep(int x, int fa) {
    t[d[x]]++;
    for(int i = h[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if(vis[y] || y == fa) continue;
        d[y] = (d[x] + e[i].w) % 3;
        getdep(y, x);
    }
}
int cal(int x, int v) {
    t[0] = t[1] = t[2] = 0;
    d[x] = v % 3;
    getdep(x, 0);
    return t[0] * t[0] + t[1] * t[2] * 2;
}
void solve(int x) {
    vis[x] = 1;
    ans += cal(x, 0);
    for(int i = h[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if(vis[y]) continue;
        ans -= cal(y, e[i].w);
        solve(getrt(y));
    }
}
int main() {
    int n;
    scanf("%d", &n);
    for(int i = 1, u, v, w; i < n; i++) {
        scanf("%d%d%d", &u, &v, &w);
        add_edge(u, v, w);
    }
    solve(getrt(1));
    printf("%d/%d\n", ans / __gcd(ans, n * n), n * n / __gcd(ans, n * n));
    return 0;
}
\end{lstlisting}

Example:bzoj2599 Race\\
给一棵树,每条边有权.求一条路径,权值和等于K,且边的数量最小.数据范围：N<=2e5, K<=1e6\\
解：\\
开一个100W的数组t,t[i]表示权值为i的路径最少边数\\
找到重心分成若干子树后， 得出一棵子树的所有点到根的权值和x，到根a条边，用t[k-x]+a更新答案，全部查询完后，再用所有a更新t[x]\\
这样可以保证不出现点分治中的不合法情况\\
\begin{lstlisting}
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int MAXN = 200003;
const int INF = 0x3f3f3f3f;
struct Edge {
    int to, nxt, w;
    Edge() {}
    Edge(int _to, int _nxt, int _w):to(_to), nxt(_nxt), w(_w) {}
}e[MAXN << 1];
int h[MAXN], p;
int sz[MAXN], dep[MAXN], d[MAXN], t[1000003];
bool vis[MAXN];
int n, k, ans;
inline void add_edge(int u, int v, int w) {
    e[++p] = Edge(v, h[u], w); h[u] = p;
    e[++p] = Edge(u, h[v], w); h[v] = p;
}
int getsz(int x, int fa) {
    sz[x] = 1;
    for(int i = h[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if(vis[y] || y == fa) continue;
        sz[x] += getsz(y, x);
    }
    return sz[x];
}
int getrt(int x) {
    int tot = getsz(x, 0) >> 1;
    while(1) {
        int u = -1;
        for(int i = h[x]; i; i = e[i].nxt) {
            int y = e[i].to;
            if(vis[y] || sz[y] > sz[x]) continue;
            if(u == -1 || sz[y] > sz[u]) u = y;
        }
        if(~u && sz[u] > tot) x = u;
        else break;
    }
    return x;
}
void getdep(int x, int fa) {
    if(d[x] > k) return;
    ans = min(ans, t[k - d[x]] + dep[x]);
    for(int i = h[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if(vis[y] || y == fa) continue;
        d[y] = d[x] + e[i].w;
        dep[y] = dep[x] + 1;
        getdep(y, x);
    }
}
void update(int x, int fa, int fg) {
    if(d[x] > k) return;
    if(fg) t[d[x]] = min(t[d[x]], dep[x]);
    else t[d[x]] = INF;
    for(int i = h[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if(vis[y] || y == fa) continue;
        update(y, x, fg);
    }
}
void cal(int x, int w) {
    d[x] = w; dep[x] = 1;
    getdep(x, 0);
}
void solve(int x) {
    vis[x] = 1;
    for(int i = h[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if(vis[y]) continue;
        cal(y, e[i].w);
        update(y, 0, 1);
    }
    for(int i = h[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if(vis[y]) continue;
        update(y, 0, 0);
    }
    for(int i = h[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if(vis[y]) continue;
        solve(getrt(y));
    }
}
int main() {
    scanf("%d%d", &n, &k);
    for(int i = 1, u, v, w; i < n; i++) {
        scanf("%d%d%d", &u, &v, &w);
        add_edge(u + 1, v + 1, w);
    }
    ans = INF;
    memset(t, 0x3f, sizeof(t));
    t[0] = 0;
    solve(getrt(1));
    if(ans != INF) printf("%d\n", ans);
    else puts("-1");
    return 0;
}
\end{lstlisting}

Example:bzoj3697 采药人的路径\\
采药人的药田是一个树状结构，每条路径上都种植着同种药材。
采药人以自己对药材独到的见解，对每种药材进行了分类。大致分为两类，一种是阴性的，一种是阳性的。
采药人每天都要进行采药活动。他选择的路径是很有讲究的，他认为阴阳平衡是很重要的，所以他走的一定是两种药材数目相等的路径。采药工作是很辛苦的，所以他希望他选出的路径中有一个可以作为休息站的节点（不包括起点和终点），满足起点到休息站和休息站到终点的路径也是阴阳平衡的。他想知道他一共可以选择多少种不同的路径。\\
解：\\
本题可以考虑树的点分治。问题就变成求过根满足条件的路径数。\\
路径上的休息站一定是在起点到根的路径上，或者根到终点的路径上。\\
如何判断一条从根出发的路径是否包含休息站？只要在dfs中记录下这条路径的和x，同时用个标志数组判断这条路径是否存在前缀和为x的节点。\\
这样我们枚举根节点的每个子树。用f[i][0…1]，g[i][0…1]分别表示前面几个子树以及当前子树和为i的路径数目，0和1用于区分路径上是否存在前缀和为i的节点。\\
那么当前子树的贡献就是$f[0][0] * g[0][0] + \sum f [i][0] * g [-i][1] + f[i][1] * g[-i][0] + f[i][1] * g[-i][1]$，其中i的范围[-d,d]，d为当前子树的深度。
\begin{lstlisting}
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
const int MAXN = 100003;
struct Edge {
    int to, nxt, w;
    Edge() {}
    Edge(int _to, int _nxt, int _w):to(_to), nxt(_nxt), w(_w) {}
}e[MAXN << 1];
int h[MAXN], p;
int sz[MAXN], dep[MAXN], d[MAXN];
int t[MAXN << 1];
ll ans, f[MAXN << 1][2], g[MAXN << 1][2];//分别表示前面几个子树以及当前子树和为i-n的路径数目，0和1用于区分路径上是否存在前缀和为i-n的节点
bool vis[MAXN];
int n;
inline void add_edge(int u, int v, int w) {
    e[++p] = Edge(v, h[u], w); h[u] = p;
    e[++p] = Edge(u, h[v], w); h[v] = p;
}
int getsz(int x, int fa) {
    sz[x] = 1;
    for(int i = h[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if(vis[y] || y == fa) continue;
        sz[x] += getsz(y, x);
    }
    return sz[x];
}
int getrt(int x) {
    int tot = getsz(x, 0) >> 1;
    while(1) {
        int u = -1;
        for(int i = h[x]; i; i = e[i].nxt) {
            int y = e[i].to;
            if(vis[y] || sz[y] > sz[x]) continue;
            if(u == -1 || sz[y] > sz[u]) u = y;
        }
        if(~u && sz[u] > tot) x = u;
        else break;
    }
    return x;
}
int getdep(int x, int fa) {
    int mx = dep[x];
    if(t[d[x]]) f[d[x]][1]++;
    else f[d[x]][0]++;
    t[d[x]]++;
    for(int i = h[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if(vis[y] || y == fa) continue;
        d[y] = d[x] + e[i].w;
        dep[y] = dep[x] + 1;
        mx = max(mx, getdep(y, x));
    }
    t[d[x]]--;
    return mx;
}
ll cal(int x) {
    int mx = 0, mxd;
    ll res = 0;
    g[n][0] = 1;//初始化子树和为0的边数量为1
    for(int i = h[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if(vis[y]) continue;
        d[y] = n + e[i].w;
        dep[y] = 1;
        mx = max(mx, mxd = getdep(y, 0));
        res += (g[n][0] - 1) * f[n][0];
        for(int j = -mxd; j <= mxd; j++)
            res += f[n + j][0] * g[n - j][1] + f[n + j][1] * g[n - j][0] + f[n + j][1] * g[n - j][1];
        for(int j = n - mxd; j <= n + mxd; j++) {
            g[j][0] += f[j][0];
            g[j][1] += f[j][1];
            f[j][0] = f[j][1] = 0;
        }
    }
    for(int i = n - mx; i <= n + mx; i++) g[i][0] = g[i][1] = 0;
    return res;
}
void solve(int x) {
    vis[x] = 1;
    ans += cal(x);
    for(int i = h[x]; i; i = e[i].nxt)
        if(!vis[e[i].to]) solve(getrt(e[i].to));
}
int main() {
    scanf("%d", &n);
    for(int i = 1, u, v, w; i < n; i++) {
        scanf("%d%d%d", &u, &v, &w); if(!w) w = -1;
        add_edge(u, v, w);
    }
    solve(getrt(1));
    printf("%lld\n", ans);
    return 0;
}
\end{lstlisting}

Example: hdu 4670 Cube number on a tree\\
题目大意：树上路径乘积为立方数的路径数\\
解：立方数的性质是每个因子的个数为3的倍数，那么每个因子只需要保存0-2三个状态即可，然后路径就可以转化为一个K位3进制数，点分治后，便可以用一个map来查询路径经过根的答案。\\
\begin{lstlisting}
#pragma comment(linker, "/STACK:1024000000,1024000000")
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int MAXN = 50003;
struct Edge {
    int to, nxt;
}e[MAXN << 1];
int head[MAXN], ecnt;
int sz[MAXN];
LL d[MAXN], ans;
LL p[MAXN];
LL prime[31];
LL pw[31];
int k, cnt;
int vis[MAXN];
unordered_map<LL, int> Hash;
LL s[MAXN];
inline void add_edge(int u, int v) {
    e[++ecnt] = (Edge) {v, head[u]}; head[u] = ecnt;
    e[++ecnt] = (Edge) {u, head[v]}; head[v] = ecnt;
}
int getsz(int x, int fa) {
    sz[x] = 1;
    for(int i = head[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if(vis[y] || y == fa) continue;
        sz[x] += getsz(y, x);
    }
    return sz[x];
}
int getrt(int x) {
    int tot = getsz(x, 0) / 2;
    while(1) {
        int u = -1;
        for(int i = head[x]; i; i = e[i].nxt) {
            int y = e[i].to;
            if(vis[y] || sz[y] > sz[x]) continue;
            if(u == -1 || sz[y] > sz[u]) u = y;
        }
        if(~u && sz[u] > tot) x = u;
        else break;
    }
    return x;
}
LL inv(LL x) {
    LL res = 0;
    for(int i = 0; i < k; i++) res += (3 - x / pw[i] % 3 ) % 3 * pw[i];
    return res;
}
LL add(LL x, LL y) {
    LL res = 0;
    for(int i = 0; i < k; i++) res += (x / pw[i] % 3 + y / pw[i] % 3 + 3) % 3 * pw[i];
    return res;
}
void upd(LL x) {
    if(!Hash.count(x)) Hash[x] = 0;
    Hash[x]++;
}
void getdep(int x, int fa) {
    s[++cnt] = d[x];
    for(int i = head[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if(vis[y] || y == fa) continue;
        d[y] = add(d[x], p[y]);
        getdep(y, x);
    }
}
LL cal(int x, LL v) {
    cnt = 0;
    Hash.clear();
    getdep(x, 0);
    LL res = 0;
    for(int i = 1; i <= cnt; i++) {
        res += Hash[inv(s[i])];
        Hash[add(s[i], -v)]++;
    }
    return res;
}
void solve(int x) {
    vis[x] = 1;
    d[x] = p[x];
    ans += cal(x, p[x]) + (p[x] == 0);
    for(int i = head[x]; i; i = e[i].nxt) {
        int y = e[i].to;
        if(vis[y]) continue;
        d[y] = add(p[x], p[y]);
        ans -= cal(y, p[x]);
        solve(getrt(y));
    }
}
inline void init(int n) {
    for(int i = 0; i <= n; i++) {
        vis[i] = head[i] = 0;
    }
    ans = 0; ecnt = 0;
}
int main() {
    pw[0] = 1;
    for(int i = 1; i < 30; i++) pw[i] = pw[i - 1] * 3;
    int n;
    while(~scanf("%d%d", &n, &k)) {
        init(n);
        for(int i = 0; i < k; i++) scanf("%lld", prime + i);
        LL tmp;
        for(int i = 1; i <= n; i++) {
            scanf("%lld", &tmp);
            p[i] = 0;
            for(int j = 0; j < k; j++) {
                int cur = 0;
                while(tmp % prime[j] == 0) {
                    cur++;
                    tmp /= prime[j];
                }
                p[i] += cur % 3 * pw[j];
            }
        }
        for(int i = 1, u, v; i < n; i++) {
            scanf("%d%d", &u, &v);
            add_edge(u, v);
        }
        solve(getrt(1));
        printf("%lld\n", ans);
    }
    return 0;
}
\end{lstlisting}

\subsection{LCA}
尚未开始
\subsection{Tarjan}
尚未开始
\subsection{Cactus}
Tarjan缩点后，每个BCC内的点为圆点，连到同一个方点。\\

Example:bzoj2125 最短路\\
仙人掌上q次询问两点最短路径\\
做法：加边权。如果一条边是圆圆边，那么就是原来的边权，如果是圆方边，那么边权等于环的根到那个圆点的最短路径长度。现在我们要询问两个点的最短路，我们查一下lca，如果是圆点，那么这个最短路就是树上的长度。如果是方点，我们倍增跳到这个环上，在每个环上记一下前缀和，判一下走哪一侧就行了。\\
\begin{lstlisting}
// 2125最短路.cpp
#include <bits/stdc++.h>
using namespace std;
inline int read() {
    int x = 0, ch = getchar(); bool fg = 1;
    while(ch < '0' || ch > '9') { if(ch == '-') fg = 0; ch = getchar(); } 
    while(ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
    return fg ? x : -x;
}
typedef pair<int, int> P;
const int MAXN = 2e4 + 5;
const int S = 15;
namespace Tree {
    struct Edge {
        int to, nxt, w;
    }e[MAXN << 1];
    int ecnt, head[MAXN];
    int rt, isrt[MAXN], fa[MAXN][S + 3];
    int sz[MAXN];
    inline void addEdge(int u, int v, int w) {
        e[++ecnt] = (Edge) {v, head[u], w}; head[u] = ecnt;
        fa[v][0] = u;
    }
}
int n, m, Q;
namespace BCC{
    struct Edge {
        int to, nxt, w;
    }e[MAXN << 1];
    int ecnt, head[MAXN];
    int dfs_clock, dfn[MAXN], low[MAXN];
    int is_vertex[MAXN], vbcc_cnt, vbccno[MAXN];
    vector<P> vbcc[MAXN];
    stack<P> vs;
    int tag[MAXN];
    inline void addEdge(int u, int v, int w) {
        e[++ecnt] = (Edge) {v, head[u], w}; head[u] = ecnt;
        e[++ecnt] = (Edge) {u, head[v], w}; head[v] = ecnt;
    }
    inline void init(int n) {
        ecnt = 1;
        dfs_clock = 0;
        vbcc_cnt = 0;
        for(int i = 0; i <= 2 * n; i++){
            head[i] = dfn[i] = low[i] = 0;
            vbccno[i] = 0;
            tag[i] = 0;
        }
        while(!vs.empty()) vs.pop();
    }
    //root's edge = -1;
    void tarjan(int u, int edge) {
        dfn[u] = low[u] = ++dfs_clock;
        vs.push(P(u, e[edge ^ 1].w));
        for(int i = head[u], v; i; i = e[i].nxt) {
            if(!dfn[v = e[i].to]) {
                tarjan(v, i ^ 1);
                low[u] = min(low[u], low[v]);
                if(low[v] >= dfn[u]) {
                    if(vs.top().first == v) {
                        Tree::addEdge(u, v, vs.top().second);
                        vs.pop();
                        continue;
                    }
                    vbcc[++vbcc_cnt].clear();
                    vbcc[vbcc_cnt].push_back(P(u, 0));
                    Tree::isrt[u] = 1;
                    int &sz = Tree::sz[n + vbcc_cnt];
                    tag[vs.top().first] = n + vbcc_cnt;
                    //Tree::addEdge(u, rt, 0);
                    for(P x;;) {
                        x = vs.top(); vs.pop();
                        sz += x.second;
                        //Tree::addEdge(rt, x.first, sz);
                        vbcc[vbcc_cnt].push_back(x);
                        vbccno[x.first] = vbcc_cnt;
                        if(x.first == v) break;
                    }
                }
            }
            else if(dfn[v] < dfn[u] && i != edge) 
                low[u] = min(low[u], dfn[v]);
        }
        for(int i = head[u], v; i; i = e[i].nxt) {
            if(tag[v = e[i].to]) {
                int r = tag[v]; Tree::sz[r] += e[i].w;
                tag[v] = 0;
            }
        }
    }
    void findBCC(int n) {
        for(int i = 1; i <= n; i++)
            if(!dfn[i]) tarjan(i, -1);
    }
}
namespace Tree {
    int dis[MAXN], dep[MAXN], len[MAXN];
    inline void init(int n) {
        BCC::init(n);
        rt = n;
        ecnt = 1;
        for(int i = 0; i <= 2 * n; i++) {
            head[i] = 0;
            fa[i][0] = isrt[i] = dis[i] = dep[i]  = len[i] = 0;
        }
    }
    void dfs(int x) {
        for(int i = head[x], y; i; i = e[i].nxt) {
            if(!dep[y = e[i].to]) {
                dep[y] = dep[x] + 1;
                dis[y] = dis[x] + e[i].w;
                dfs(y);
            }
        }
    }
    void pre() {
        for(int k = 1; k <= BCC::vbcc_cnt; k++) {
            rt++;
            vector<P> &E = BCC::vbcc[k];
            addEdge(E[0].first, rt, 0);
            int cnt = 0;
            for(int i = E.size() - 1; i >= 1; i--) {
                cnt += E[i].second;
                len[E[i].first] = cnt;
                addEdge(rt, E[i].first, min(cnt, sz[rt] - cnt));
            }
        }
        for(int k = 1; k <= S; k++) {
            for(int i = 1; i <= rt; i++) {
                fa[i][k] = fa[fa[i][k - 1]][k - 1];
            }
        }
        dep[1] = 1;
        dfs(1);
    }
    int up(int x, int d) {
        for(int i = S; i >= 0; i--) {
            if(dep[fa[x][i]] >= d) x = fa[x][i];
        }
        return x;
    }
    int lca(int u, int v) {
        if(dep[u] > dep[v]) swap(u, v);
        v = up(v, dep[u]);
        if(u == v) return u;
        for(int i = S; i >= 0; i--) {
            if(fa[u][i] != fa[v][i]) {
                u = fa[u][i], v = fa[v][i];
            }
        }
        return fa[u][0];
    }
    int query(int u, int v) {
        int l = lca(u, v);
        if(l <= n) return dis[u] + dis[v] - 2 * dis[l];
        int x = up(u, dep[l] + 1), y = up(v, dep[l] + 1);
        int res = dis[u] - dis[x] + dis[v] - dis[y];
        int tmp = abs(len[x] - len[y]);
        return res + min(tmp, sz[l] - tmp);
    }
}

int main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.precision(6); cout << fixed;
    using namespace Tree;
    cin >> n >> m >> Q;
    init(n);
    for(int i = 1, u, v, w; i <= m; i++) {
        cin >> u >> v >> w;
        BCC::addEdge(u, v, w);
    }
    BCC::findBCC(n);
    pre();
    int u, v;
    while(Q--) {
        cin >> u >> v;
        cout << query(u, v) << endl;
    }
    return 0;
}
\end{lstlisting}

Example:bzoj4316 小C的独立集\\
仙人掌上的最大独立集\\
做法：dp[x][0/1]为x不选/选时这棵子树内的最大独立集。类似于树上dp，考虑如果圆点的dp方程不变，方点的dp就应该是：dp[x][0]表示这个点的父亲选，dp[x][1]表示这个点的父亲可以选也可以不选。
\begin{lstlisting}
// 4316小C的独立集.cpp
#include <bits/stdc++.h>
using namespace std;

inline int read() {
    int x = 0, ch = getchar(); bool fg = 1;
    while(ch < '0' || ch > '9') { if(ch == '-') fg = 0; ch = getchar(); } 
    while(ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
    return fg ? x : -x;
}
const int MAXN = 1e6 + 5;
int n, m;
namespace Tree {
    vector<int> G[MAXN];
    int rt[MAXN];
    inline void addEdge(int u, int v) {
        G[u].push_back(v);
    }
}
namespace BCC{
    struct Edge {
        int to, nxt;
    }e[MAXN << 1];
    int ecnt, head[MAXN];
    int dfs_clock, dfn[MAXN], low[MAXN];
    int is_vertex[MAXN], vbcc_cnt, vbccno[MAXN];
    vector<int> vbcc[MAXN];
    stack<int> vS;
    inline void addEdge(int u, int v) {
        e[++ecnt] = (Edge) {v, head[u]}; head[u] = ecnt;
        e[++ecnt] = (Edge) {u, head[v]}; head[v] = ecnt;
    }
    inline void init(int n) {
        ecnt = 1;
        dfs_clock = 0;
        vbcc_cnt = 0;
        for(int i = 1; i <= n; i++){
            head[i] = dfn[i] = low[i] = 0;
            is_vertex[i] = 0;
            vbccno[i] = 0;
        }
        while(!vS.empty()) vS.pop();
    }
    //root's edge = -1;
    void tarjan(int u, int edge) {
        dfn[u] = low[u] = ++dfs_clock;
        int ch = 0;
        vS.push(u);
        for(int i = head[u], v; i; i = e[i].nxt) {
            if(!dfn[v = e[i].to]) {
                tarjan(v, i ^ 1);
                low[u] = min(low[u], low[v]);
                if(low[v] >= dfn[u]) {
                    ch++;
                    if(edge > 0 || ch > 1) is_vertex[u] = 1;
                    if(vS.top() == v) {
                        vS.pop();
                        Tree::addEdge(u, v);
                        continue;
                    }
                    vbcc[++vbcc_cnt].clear();
                    vbcc[vbcc_cnt].push_back(u);
                    int rt = n + vbcc_cnt;
                    Tree::rt[u] = 1;
                    Tree::addEdge(u, rt);
                    for(int x;;) {
                        x = vS.top(); vS.pop();
                        Tree::addEdge(rt, x);
                        vbcc[vbcc_cnt].push_back(x);
                        vbccno[x] = vbcc_cnt;
                        if(x == v) break;
                    }
                }
            }
            else if(dfn[v] < dfn[u] && i != edge) 
                low[u] = min(low[u], dfn[v]);
        }
    }
    void findBCC(int n){
        for(int i = 1; i <= n; i++)
            if(!dfn[i]) tarjan(i, -1);
    }
}
namespace Tree {
    int vis[MAXN], dp[MAXN][2];
    int tmp[MAXN][2];
    inline void init(int n) {
        BCC::init(n);
        for(int i = 1; i <= n; i++) {
            G[i].clear();
            dp[i][0] = dp[i][1] = vis[i] = rt[i] = 0;
        }
    }
    void dfs(int x) {
        if(vis[x]) return;
        vis[x] = 1;
        if(!rt[x] && x <= n) {
            dp[x][1] = 1; dp[x][0] = 0;
            for(auto y : G[x]) {
                dfs(y);
                dp[x][1] += dp[y][0];
                dp[x][0] += max(dp[y][0], dp[y][1]);
            }
        }
        else {
            vector<int> &E = G[x];
            for(auto y : E) dfs(y);
            if(x <= n) {
                dp[x][1] = 1; dp[x][0] = 0;
                for(auto y : E) {
                    dp[x][1] += dp[y][1];
                    dp[x][0] += max(dp[y][0], dp[y][1]);
                }
                return;
            }
            int u, v;
            //第一个点不加
            tmp[E[0]][0] = tmp[E[0]][1] = 0;
            for(int i = 1; i < E.size(); i++) {
                v = E[i], u = E[i - 1];
                tmp[v][1] = dp[v][1] + tmp[u][0];
                tmp[v][0] = dp[v][0] + max(tmp[u][0], tmp[u][1]);
            }
            u = E.front(), v  = E.back();
            dp[x][1] = tmp[v][0] + dp[u][0];
            //第一个点加
            tmp[E[0]][0] = dp[E[0]][0];
            tmp[E[0]][1] = dp[E[0]][1];
            for(int i = 1; i < E.size(); i++) {
                v = E[i], u = E[i - 1];
                tmp[v][1] = dp[v][1] + tmp[u][0];
                tmp[v][0] = dp[v][0] + max(tmp[u][0], tmp[u][1]);
            }
            dp[x][0] = max(tmp[v][0], tmp[v][1]);
        }
    }
}
int main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.precision(6); cout << fixed;
    using namespace Tree;
    cin >> n >> m;
    init(n);
    for(int i = 1, u, v; i <= m; i++) {
        cin >> u >> v;
        BCC::addEdge(u, v);
    }
    BCC::findBCC(n);
    int ans = 0;
    for(int i = 1; i <= n; i++) {
        if(!vis[i]) dfs(i);
        ans = max(ans, max(dp[i][0], dp[i][1]));
    }
    cout << ans << endl;
    return 0;
}
\end{lstlisting}

\newpage
\section{Data Structures}
\subsection{Basic Structures}
尚未开始
\subsection{Heap Structures}
尚未开始
\subsection{Sequence Structures}
尚未开始
\subsection{Persistent Data Structures}
尚未开始
\subsection{Tree Structures}
尚未开始


\newpage
\section{String}
\subsection{Basics}
尚未开始
\subsection{String Matching}
尚未开始
\subsection{Suffix Related}
尚未开始
\subsection{Palindrome Related}
周期：若$0 < p \leq |S|, {\forall}1 \leq i \leq{|s|-p}, s[i] = s[i+p]$ 就称p是s的周期\\
border：若$0 \leq r < |S|, pre(s, r) = suf(s,r)$ 就称pre(s,r)是s的border\\
周期和 border 的关系：t是s的border，当且仅当$|s| - |t|$是s的周期\\
t是回文串s的后缀，t是s的 border当且仅当t是回文串\\
t是回文串s的border($|s|\leq 2|t|$)，s是回文串当且仅当t是回文串\\
t是回文串s的border，则|s|-|t|是s的周期，|s|-|t|为s的最小周期，当且仅当t是s的最长回文真后缀\\
x是一个回文串，y是x的最长回文真后缀，z是y的最长回文真后缀。令u,v分别为满足x=uy,y=vz的字符串，则有下面三条性质\\
1. $|u| \geq |v|$\\
2. 如果$|u| > |v|$，那么$ |u| > |z|$\\
3. 如果$|u| = |v|$，那么$ u = v$\\
推论：s的所有回文后缀按照长度排序后，可以划分成log|s|段等差数列\\
遍历回文自动机的fail链，能得到当前串的所有Border\\

1. 计算以该i结尾的回文子串个数. 解：输出num[i];\\
2. 计算本质不同的(奇/偶/总)回文串个数. 解：奇回文for(int i = 2; i < pcnt; i++) if(len[i]\%2 == 1) ++ans;\\
3. 计算(奇/偶/总)回文串个数. 解：\\
奇回文for(int i = 2; i < pcnt; i++) if(len[i]\%2 == 1) ans += cnt[i];\\
动态情况下，总串累计num[i]
4. 计算$ww^{-1}ww^{-1}$的最长长度. 解: if(len[trans[last]]+len[trans[last]]==len[last] \&\& len[last]\%4==0) ans = max(ans, len[last]);\\
5. 计算 $aa^{-1}bb^{-1}$ 的最长长度. 解：正反各建立一颗回文树，以i-1结尾的最长回文串和以i开始的最长回文串最大值即为答案\\
6. 计算相交回文串的个数. 输入：字符串长度n($1<=n<=2*10^6$)、字符串. 解: 总数 - 计算不相交的个数\\
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int MAXN = 2e6 + 7;
const LL MOD = 51123987;
namespace PAM {
	int scnt, S[MAXN];
	int pcnt, last, len[MAXN], fail[MAXN];
	struct node{int c, pos, nxt;} e[MAXN];
	int ecnt, head[MAXN];
	int num[MAXN];
	int newnode(int _len) {
		len[pcnt] = _len;
		num[pcnt] = head[pcnt] = 0;
		return pcnt++;
	}
	inline void init() {
		S[scnt = 0] = -1;
		pcnt = 0;newnode(0);newnode(-1);
		fail[0] = 1;last = 0;
		ecnt = 0;
		memset(head, 0, sizeof head);
	}
	int getfail(int x) {
		while(S[scnt - len[x] - 1] != S[scnt]) x = fail[x];
		return x;
	}
	int ch(int u, int c) {
		for(int i = head[u]; i; i = e[i].nxt) if(e[i].c == c) return e[i].pos;
		return 0;
	}
	void setCh(int u, int c, int pos) {
		e[++ecnt] = (node) {c, pos, head[u]}; head[u] = ecnt;
	}
	void extend(int c) {
		S[++scnt] = c;
		int cur = getfail(last);
		if(!(last = ch(cur, c))) {
			last = newnode(len[cur] + 2);
			fail[last] = ch(getfail(fail[cur]), c);
			setCh(cur, c, last);
			num[last] = num[fail[last]] + 1;
		}
	}
};
using namespace PAM;
LL sum[MAXN];
int main() {
    ios::sync_with_stdio(false); cin.tie(0);
	int n; cin >> n;
	string s; cin >> s;
	init();
	for(int i = 1; i <= n; i++) {
		extend(s[i-1] - 'a');
		sum[i] = sum[i-1] + num[last];
		if(sum[i] >= MOD) sum[i] -= MOD;
	} 
	LL ans = sum[n] * (sum[n] - 1) / 2;
	init();
	for(int i = n; i; i--) {
		extend(s[i-1] - 'a');
		ans = (ans - sum[i-1] * num[last] % MOD + MOD) % MOD ;
	}
	cout << ans << endl;
	return 0;
} 
\end{lstlisting}
7. {操作一: 串开头或末尾加一个字符, 操作二: 串开头或末尾加一个该串的逆串} 从空串到指定串最少步骤\\
解：每个偶回文串v的情况为: min(dp[u] + 1, dp[trans[v]] + len[v]/2 - len[trans[v]] + 1); 答案为 min(ans, dp[v] + n - len[v])\\

8. 公共回文子串的个数,重复计算. 输入两个串s1，s2. 解：分别建立回文树，在两颗树上同时跑
\begin{lstlisting}
int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    string s1, s2; cin >> s1 >> s2;
    T1.init();for(auto it : s1) T1.extend(it-'A');T1.count();
    T2.init();for(auto it : s2) T2.extend(it-'A');T2.count();
    queue<pair<int,int> > q;
    q.push({0, 0}); q.push({1, 1});
    LL ans = 0;
    while(!q.empty()) {
        int cur1 = q.front().first, cur2 = q.front().second; q.pop();
        for(int i = 0; i < 26; i++) {
            int t1 = T1.ch[cur1][i], t2 = T2.ch[cur2][i]; 
            if(t1 && t2) {
                q.push({t1, t2});
                ans += (LL)T1.cnt[t1] * T2.cnt[t2];
            }
        }
    }
    cout << ans<< endl;
    return 0;
} 
\end{lstlisting}
9. 给定一个串S，把串分为偶数段, 假设分为了s1,s2,s3....sk, 求满足$s_1=s_k,s_2=s_{k-1}......$的方案数
解： 题目转化为$S'= S_1S_nS_2S_{n−2}...$, 求把S'分为若干个长度为偶数的回文串的方案数
辅助数组g: g[v] 表示v所在的等差数列的dp值之和, 且v是这个等差数列中长度最长的节点
$g[v] = \sum_{x, slink[x]=v} dp[i - len[x]]$
$g[v] = g[fail[x]] + 多出来的一个位置的dp 之和$, 多出来的这个位置为$i - (len[slink] + diff[x])$
然后利用g[v] 更新 f[i], 正确性依赖于：如果v和fail[v]属于同一个等差数列，那么fail[x]上一次出现位置是i-diff[v]
无论f[i]是否要求修改，都要更新对应位置的g
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e6 + 7;
int MOD = 1e9 + 7;
namespace PAM {
    int scnt, S[MAXN];
    int pcnt, last, len[MAXN], fail[MAXN], ch[MAXN][26];
    int diff[MAXN], slink[MAXN];
    int newnode(int _len) {
        len[pcnt] = _len; diff[pcnt] = slink[pcnt] = 0;
        for(int i = 0; i < 26; i++) ch[pcnt][i] = 0;
        return pcnt++;
    }
    inline void init() {
        S[scnt = 0] = -1;
        pcnt = 0;newnode(0);newnode(-1);
        fail[0] = 1;last = 0;
    }
    int getfail(int x) {
        while(S[scnt - len[x] - 1] != S[scnt]) x = fail[x];
        return x;
    }
    void extend(int c) {
        S[++scnt] = c;
        int cur = getfail(last);
        if(!ch[cur][c]) {
            int now = newnode(len[cur] + 2);
            fail[now] = ch[getfail(fail[cur])][c];
            ch[cur][c] = now;
            diff[now] = len[now] - len[fail[now]];
            slink[now] = (diff[now] == diff[fail[now]]) ? slink[fail[now]] : fail[now];
        }
        last = ch[cur][c];
    }
};
using namespace PAM;
int g[MAXN], f[MAXN];
void sol(int i, int cur) {
	for(; cur; cur = slink[cur]) {
		g[cur] = f[i - len[slink[cur]] - diff[cur]];
		if (slink[cur] != fail[cur]) g[cur] = (g[cur] + g[fail[cur]])%MOD;
		f[i] = (f[i] + g[cur]) % MOD;
	}
}
int main() {
    ios::sync_with_stdio(false); cin.tie(0);
	string s; cin >> s;
	int sn = s.size();
	init();f[0]=1;
	for(int i = 0; i < sn; i += 2) {
		extend(s[i >> 1] - 'a');sol(i+1, last); f[i+1] = 0;
		extend(s[sn-1 - (i>>1)] - 'a'); sol(i+2, last);
	} 
	cout << f[sn] << endl;
	return 0;
} 
\end{lstlisting}
10. 前后均支持插入，利用不基于势能分析的PAM模板
11. 在Trie上构建回文自动机
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5 + 7;
int MOD = 1e9 + 7;
namespace PAM {
    int scnt, S[MAXN<<1];
    int pcnt, last[MAXN];
    int len[MAXN<<1], fa[MAXN<<1], quick[MAXN<<1][26], ch[MAXN<<1][26];
    int newnode(int _len) {
        len[pcnt] = _len;
        for(int i = 0; i < 26; i++) ch[pcnt][i] = 0;
        return pcnt++;
    }
    inline void init() {
        pcnt = 0;newnode(0);newnode(-1);
        fa[0] = 1;
        for(int i = 0; i < 26; i++) quick[0][i] = quick[1][i] = 1;
        S[scnt = 0] = -1;
    }
    int extend(int p, int c) {
        if (S[scnt-len[p]-1] ^ c) p = quick[p][c];
        if (!ch[p][c]) {
            int np = newnode(len[p]+2), q = fa[p];
            if (S[scnt-len[q]-1] ^ c) q = quick[q][c];
            fa[np] = ch[q][c];
            memcpy(quick[np],quick[fa[np]], sizeof(quick[np]));
            quick[np][S[scnt-len[fa[np]]]] = fa[np];
            ch[p][c] = np;
        }
        return ch[p][c];
    }
    int ilen[MAXN]; char s[MAXN];
    long long ans;
    vector<int> G[MAXN];
    void dfs(int u, int _fa) {
        S[++scnt] = s[u] - 'a';
        last[u] = extend(last[_fa], s[u]-'a'); 
        ilen[u] = max(len[last[u]], ilen[_fa]);
        ans += ilen[u];
        for(auto v : G[u]) if(v != _fa) dfs(v, u);
        --scnt;
    }
};
using namespace PAM;  
int main() {
    int n; scanf("%d", &n);
    scanf("%s", s + 1);
    init();
    for(int i = 1; i < n; i++) {
        int x, y;
        cin >> x >> y;
        G[x].push_back(y);
        G[y].push_back(x);
    } 
    dfs(1, 0);
    printf("%lld", ans);
    return 0;
} 
\end{lstlisting}

\subsection{Substring Automaton}
求解 子序列个数，不重复, 包括空串
\begin{lstlisting}
int dfs(int x) {
    if(dp[x]) return dp[x];
    dp[x] = 1;
    for(int i = 0; i < 26; i++)
        if(ch[x][i] != -1) dp[x] += dfs(ch[x][i]);
    return dp[x];
}    
\end{lstlisting}
求解 回文公共子序列个数，不重复，包括空串\\
原串与反串都建一遍,这样有两个字符串,x+y<=n+1这个序列才是合法的\\
x+y=n+1以外的情况统计奇回文序列要++f[x][y]\\
特殊处理x+y=n+1、x+y<n+1时不++f[x][y], 可以统计偶回文序列\\
相减可以统计奇回文序列
\begin{lstlisting}
LL dfs(LL x,LL y) {
    if(f[x][y]) return f[x][y];
    for(LL i = 0; i < 26; i++)
    if(ch1[x][i] != -1 && ch2[y][i] != -1) {
        if(ch1[x][i]+ch2[y][i] > n+1) continue;
        if(ch1[x][i]+ch2[y][i] < n+1) f[x][y]++;
        f[x][y] = (f[x][y]+dfs(ch1[x][i],ch2[y][i]))%mod;
    }
    return ++f[x][y];
}
\end{lstlisting}
求解 两个字符串的所有公共子序列个数，可重复
\begin{lstlisting}
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++) {
        f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1];
        if(arr[i]==brr[j]) f[i][j]+=f[i-1][j-1]+1;
        if(f[i][j]<0) f[i][j]+=mod;
        if(f[i][j]>=mod) f[i][j]%=mod;
    }
\end{lstlisting}
求解 两个字符串的所有公共子序列个数，去重复， 包括了空串
输入：a串长度、b串长度、a串、b串、（0：输出所有的公共子序列个数|1：按照字典序输出所有不重复公共子序列）
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL MOD = 1e9;
const int MAXN = 3020;
const int MAXM = 3e6 + 7;
const int MAXS = 58;
struct Big {//压位高精度
    int len, a[20];
    Big() {
        len = 0;
        for (int i = 0; i < 20; i++) a[i] = 0;
    }
    void put() {
        printf("%d", a[len]);
        for (int i = len - 1; i >= 0; i--) printf("%09d", a[i]);
    }
    void operator=(int o) {
        if (o >= MOD) {
            a[0] = o % MOD;
            a[len = 1] = 0 / MOD;
        } else
            a[len = 0] = o;
    }
    void operator+=(const Big& o) {
        len = max(len, o.len);
        for (int i = 0; i <= len; i++) {
            a[i] += o.a[i];
            if (a[i] >= MOD) {
                a[i + 1] += a[i] / MOD;
                a[i] %= MOD;
            }
        }
        while (a[len + 1]) len++;
    }
} dp[MAXM];

char sta[MAXN];
int top = -1;

char a[MAXN], b[MAXN];
int an, bn, k;
LL ans;
int cha[MAXN][MAXS], chb[MAXN][MAXS];

int markn, mark[MAXN][MAXN];
void build(char* s, int sn, int (*ch)[58]) {
    for (int j = 0; j < 58; j++) ch[sn][j] = ch[sn + 1][j] = -1;
    for (int i = sn; i >= 1; i--) {
        for (int j = 0; j < 58; j++) ch[i - 1][j] = ch[i][j];
        ch[i - 1][s[i] - 'A'] = i;
    }
}
int dfs0(int x, int y) {
    if (mark[x][y])
        return mark[x][y];
    int p = mark[x][y] = ++markn;
    dp[p] = 1;
    for (int i = 0; i < 58; i++) {
        if (cha[x][i] != -1 && chb[y][i] != -1) {
            dp[p] += dp[dfs0(cha[x][i], chb[y][i])];
        }
    }
    return mark[x][y];
}
LL dfs1(int x, int y) {
    puts(sta);
    LL cnt = 1;
    for (int i = 0; i < 58; i++) {
        if (cha[x][i] != -1 && chb[y][i] != -1) {
            sta[++top] = i + 'A';
            cnt += dfs1(cha[x][i], chb[y][i]);
            sta[top--] = '\0';
        }
    }
    return cnt;
}
int main() {
    scanf("%d%d%s%s%d", &an, &bn, a + 1, b + 1, &k);
    build(a, an, cha);
    build(b, bn, chb);
    if (k == 1)
        dfs1(0, 0);
    dfs0(0, 0);
    dp[mark[0][0]].put();
    return 0;
}
\end{lstlisting}



\newpage
\section{Math}
\subsection{FFT}
分治FFT:\\
对集合S，$val(s) = F_{sum(s)}$,where sum(s) is the sum of all the elements of the set.\\
Given a set S having N elements, please calculate the sum of the values of all subsets of S of size K.\\
$$
F_n = \frac{1 - a^n}{1-a}
$$
生成函数:
$$
(x+a^{s_1}) \cdot (x+a^{s_2}) \cdot \cdot \cdot (x+a^{s_n})
$$
答案为$x^{n-k}$的系数
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int MAXN = 300005, mod = 1e5 + 3, P = mod - 1;
const double pi = acos(-1.);
struct comp {
    double x, y;
    comp operator + (const comp& a) const { return (comp) {x + a.x, y + a.y}; }
    comp operator - (const comp& a) const { return (comp) {x - a.x, y - a.y}; }
    comp operator * (const comp& a) const { return (comp) {x * a.x - y * a.y, x * a.y + y * a.x}; }
};
#define conj(a) ((comp){a.x, -a.y})
int rev[MAXN], T;
comp Sin[MAXN], tmp;
void fft(comp *a, int r) {
    for(int i = 1; i < T; i++) if(rev[i] > i) swap(a[rev[i]], a[i]);
    for(int i = 2, mid = 1, s = (T >> 1); i <= T; mid = i, i <<= 1, s >>= 1) {
        for(int j = 0; j < T; j += i) {
            for(int k = j, cur = 0; k < j + mid; k++, cur += s) {
                tmp = a[k + mid] * Sin[cur];
                a[k + mid] = a[k] - tmp;
                a[k] = a[k] + tmp;
            }
        }
    }
}
comp A[MAXN];
void init(int n) {
    for(T = 1; T <= n; T <<= 1);
    for(int i = 0; i < T; i++) {
        if(i & 1) rev[i] = (rev[i >> 1] >> 1) ^ (T >> 1);
        else rev[i] = rev[i >> 1] >> 1;
        A[i] = (comp) {0, 0};
    }
    for(int i = 0; i < (T >> 1); i++) {
        Sin[i] = (comp) {cos(2 * pi * i / T), sin(2 * pi * i / T)};
    }
}
void mtt(int *x, int *y) {
    for(int i = 0; i < T; i++) (x[i] += mod) %= mod, (y[i] += mod) %= mod;
    static comp a[MAXN], b[MAXN];
    static comp dfta[MAXN], dftb[MAXN], dftc[MAXN], dftd[MAXN];
    for(int i = 0; i < T; i++) {
        a[i] = {x[i] & 0x7fff, x[i] >> 15};
        b[i] = {y[i] & 0x7fff, y[i] >> 15};
    }
    fft(a, 1); fft(b, 1);
    for(int i = 0; i < T; i++) {
        int j = (T - i) & (T - 1);
        static comp da, db, dc, dd;
        da = (a[i] + conj(a[j])) * (comp){0.5, 0};
        db = (a[i] - conj(a[j])) * (comp){0, -0.5};
        dc = (b[i] + conj(b[j])) * (comp){0.5, 0};
        dd = (b[i] - conj(b[j])) * (comp){0, -0.5};
        dfta[i] = da * dc;
        dftb[i] = da * dd;
        dftc[i] = db * dc;
        dftd[i] = db * dd;
    }
    for(int i = 0; i < T; i++) {
        a[i] = dfta[i] + dftb[i] * (comp) {0, 1};
        b[i] = dftc[i] + dftd[i] * (comp) {0, 1};
    }
    for(int i = 0; i < (T >> 1); i++) Sin[i].y = -Sin[i].y;
    fft(a, -1); fft(b, -1);
    for(int i = 0; i < T; i++) {
        static int da, db, dc, dd;
        da = (LL)(a[i].x / T + 0.5) % mod;
        db = (LL)(a[i].y / T + 0.5) % mod;
        dc = (LL)(b[i].x / T + 0.5) % mod;
        dd = (LL)(b[i].y / T + 0.5) % mod;
        x[i] = ((da + ((LL)(db + dc) << 15) + ((LL)dd << 30)) % mod + mod) % mod;
    }
}
LL f[MAXN], g[MAXN];
int x[MAXN], y[MAXN];
void solve(int l, int r) {
    if(l == r) {
        f[0] = 1;
        f[1] = g[l];
        return;
    }
    int mid = (l + r) >> 1;
    solve(l, mid);
    LL tmp[mid - l + 5];
    for(int i = 0; i <= mid - l + 1; i++) tmp[i] = f[i];
    solve(mid + 1, r);
    init(r - l + 1);
    for(int i = 0; i < T; i++) x[i] = y[i] = 0;
    for(int i = 0; i <= mid - l + 1; i++) x[i] = tmp[i];
    for(int i = 0; i <= r - mid; i++) y[i] = f[i];
    mtt(x, y);
    for(int i = 0; i <= r - l + 1; i++) {
        f[i] = x[i];
    }
}
LL fac[mod + 5], inv[mod + 5];
void init_C() {
    fac[0] = 1;
    for(int i = 1; i < mod; i++) fac[i] = fac[i - 1] * i % mod;
    inv[0] = inv[1] = 1;
    for(int i = 2; i < mod; i++) inv[i] = (mod - mod / i) * inv[mod % i] % mod;
    for(int i = 1; i < mod; i++) inv[i] = inv[i] * inv[i - 1] % mod;
}
LL C(int a, int b) {
    if(b > a) return 0;
    if(a < mod) return fac[a] * inv[b] % mod * inv[a - b] % mod;
    return C(a / mod, b / mod) * C(a % mod, b % mod) % mod;
}
LL pw[MAXN];
LL qpow(LL x, LL y) {
    LL res = 1;
    while(y) {
        if(y & 1) res = res * x % mod;
        x = x * x % mod;
        y >>= 1;
    }
    return res;
}
int main() {
    init_C();
    int n, a, Q;
    scanf("%d%d%d", &n, &a, &Q);
    pw[0] = 1;
    for(int i = 1; i < mod; i++) pw[i] = pw[i - 1] * a % mod;
    for(int i = 1, s; i <= n; i++) {
        scanf("%d", &s);
        g[i] = pw[s % P];
    }
    solve(1, n);
    int k;
    int INV = qpow(a - 1, mod - 2);
    while(Q--) {
        scanf("%d", &k);
        printf("%lld\n", (f[k] + mod - C(n, k)) % mod * INV % mod);
    }
    return 0;
}
\end{lstlisting}
\subsection{FWT}
题目大意:\\ 
给一个$n*m$矩阵$(a)_{ij}$，行向量为$v_i$, 求$\oplus_{x=0}^{2^k}(count(x) * 3^x\space mod(10^9+7))$
其中$count(x)$表示$\frac{1}{2^m}  \sum_i^n \prod_j^m (1-(-1)^{|a_{ij} \space and \space x| })$, $\oplus$表示异或,$|a|$表示a的二进制中1的个数。\\

解：\\
考虑化简以上$count(x)$,由于$(-1)^{|a\space and \space x| + |b\space and\space x|}= (-1)^{|(a \space \oplus \space b) \space and \space x|}$
则展开$\prod$后得到:
$$
\frac{1}{2^m} \sum_i^n \sum_{S \subseteq {v_i}} (-1)^{size(S)} * (-1)^{|(\oplus_{\atop j \in S}a_{ij}) \space and \space x |}
$$
其中s为枚举每个行向量的二进制集合。
  
这里可以观察到和离散沃尔什变换相似的地方，即：\\

\begin{equation*}
\left\{
    \begin{aligned}
        C_k&=\sum_{i\oplus j=k}A_i*B_j \\
        DWT(A)_i&=\sum_j^nA_j*f_{i,j} \\
        DWT(C)_i&=DWT(A)_i*DWT(B)_i\\
        f_{i,j} \cdot f_{i,k} &=f_{i,j\oplus k}\\
        f_{i,j} &= [i \ and \ j == i] \  &(and)\\
        f_{i,j} &= [i \  and \  j == j] \ &(or)\\
        f_{i,j} &= (-1)^{| i \  and \  j |} \ &(xor)
    \end{aligned}
\right.
\end{equation*}

注意到$xor$的形式与上述形式完全一致，所以令
$$cnt_x = \sum_i^n \sum_{S \in i} (-1)^{size(S)}$$
其中$x=\oplus_{\atop j \in S} a_{i,j}$，则对于$cnt$做沃尔什变换可得：
$$
DWT(cnt)_x=\sum_j^{2^k}\sum_i^n\sum_{S \subseteq v_i} (-1)^{size(S)}*(-1)^{|j \ and \ x|}
$$
由此可得：
$$count(x)=\frac{1}{2^m} *DWT(cnt)_x$$
预处理$cnt_x$复杂度$O(n\  2^m)$，$FWT$复杂度$O(k\ 2^k)$，总复杂度为$O(n \ 2^m + k \ 2^k)$

\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int mod = 1e9 + 7;
void FWT(vector<int> &a,int n) {
    for(int i = 2;i <= n; i <<= 1) {
        for(int j = 0; j < n; j += i) {
            for(int d = 0, w = i >> 1; d < w; d++){
                int u = a[j + d], v = a[j + d + w];
                a[j + d] = u + v, a[j + d + w] = u - v;
            }
        }
    }
}
void dfs(vector<int> &cnt, const vector<int> &a, int i, int x, int p) {
    if(i < a.size()) {
        dfs(cnt, a, i + 1, x, p);
        dfs(cnt, a, i + 1, x ^ a[i], -p);
    }
    else {
        cnt[x] += p;
    }
}
int main() {
    int n, m, k;
    while(~scanf("%d%d%d", &n, &m, &k)) {
        auto cnt = vector<int>(1 << k, 0);
        auto a = vector<int>(m);
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) a[j] = read();
            dfs(cnt, a, 0, 0, 1);
        }
        FWT(cnt, 1 << k);
        int ans = 0, pw = 1 << m, w = 1;
        for(int x = 0; x < (1 << k); x++) {
            ans ^= (long long)w * (cnt[x] / pw) % mod;
            w = (long long)w * 3 % mod;
        }
        printf("%d\n", ans);
    }
    return 0;
} 
\end{lstlisting}
\subsection{Functions}
题目大意：求$\Sigma_i^n\Sigma_j^mgcd(i, j) * 2 - 1$\\

解:\\
$\Sigma_i^n\Sigma_j^mgcd(i, j) * 2 - 1$\\
=$- n * m + 2 * \Sigma_i^n\Sigma_j^mgcd(i, j) $\\
=$- n * m + 2 * \Sigma_i^n\Sigma_j^m\Sigma_{d|gcd(i, j)} \phi(d) $\\
=$-n * m + 2 * \Sigma_d^{max(n, m)}\phi(d) * \lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor $\\枚举d，复杂度O(n)
\begin{lstlisting}
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
const int MAXN = 100003;
int phi[MAXN], prime[MAXN], cnt;
bool isp[MAXN];
void Euler(int n) {
    phi[1] = 1;
    for(int i = 2; i <= n; i++) {
        if(!isp[i]) {
            prime[++cnt] = i;
            phi[i] = i - 1;
        }
        for(int j = 1; j <= cnt && i * prime[j] <= n; j++) {
            isp[i * prime[j]] = 1;
            if(i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            else phi[i * prime[j]] = phi[i] * (prime[j] - 1);
        }
    }
}
long long ans;
int main() {
    int n, m, k;
    scanf("%d%d", &n, &m);
    k = max(n, m);
    Euler(k);
    ans -= (long long)n * m;
    for(int d = 1; d <= k; d++) {
        ans += 2LL * phi[d] * (n / d) * (m / d);
    }
    printf("%lld\n", ans);
    return 0;
}
\end{lstlisting}

题目大意：对于给定的整数N,M和d，有多少正整数对x,y，满足x<=N，y<=M，并且gcd(x,y)=d。\\

解：\\
等价于x<=N/d，y<=M/d，互质的x，y的对数。\\
那么我们另n=N/d, m = M/d\\
于是原题就变成了求$\Sigma_i^n\Sigma_j^me(gcd(i, j))$\\
其中$e(x) = (x == 1) = \Sigma_{d | x} \mu(d)$\\
然后根据套路我们再来推一波式子\\
$\Sigma_i^n\Sigma_j^me(gcd(i, j))$\\
=$\Sigma_i^n\Sigma_j^m\Sigma_{d|gcd(i, j)} \mu(d)$\\
=$\Sigma_d^{min(n, m)}\mu(d) * \lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor$\\
根据上一题的做法，每次询问复杂度O(n)，显然不能胜任。\\
但是我们观察式子，显然 $\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor$的取值只有$\sqrt{n} + \sqrt{m}$\\个，那么我们可以预处理$\mu$的前缀和，并分块完成。
\begin{lstlisting}
#include <cstdio>
#include <algorithm>
using namespace std;
const int MAXN = 50003;
int mu[MAXN], prime[MAXN], cnt;
bool isp[MAXN];
void Euler(int n) {
    mu[1] = 1;
    for(int i = 2; i <= n; i++) {
        if(!isp[i]) {
            prime[++cnt] = i;
            mu[i] = -1;
        }
        for(int j = 1; j <= cnt && i * prime[j] <= n; j++) {
            isp[i * prime[j]] = 1;
            if(i % prime[j] == 0) {
                mu[i * prime[j]] = 0;
                break;
            }
            mu[i * prime[j]] = -mu[i];
        }
    }
}
int cal(int n, int m) {
    if(n > m) swap(n, m);
    int res = 0, last;
    for(int i = 1; i <= n; i = last + 1) {
        last = min(n / (n / i), m / (m / i));
        res += (n / i) * (m / i) * (mu[last] - mu[i - 1]);
    }
    return res;
}
int main() {
    Euler(50000);
    for(int i = 2; i <= 50000; i++) mu[i] += mu[i - 1];
    int T, a, b, d;
    scanf("%d", &T);
    while(T--) {
        scanf("%d%d%d", &a, &b, &d); a /= d; b /= d;
        printf("%d\n", cal(a, b));
    }
    return 0;
}
\end{lstlisting}

题目大意：另F(i)表示i的约数和，q次给定n,m,a，求$\Sigma_i^n\Sigma_{j and F(gcd(i, j)) <= a}^m F(gcd(i, j)) mod 2 ^ {31}$\\

解：\\
有个a的限制，式子并不能推了。所以先把它去掉。\\
令$g(i) = \Sigma_x^n\Sigma_y^me(gcd(x, y) == i)$\\
那么可以得到$g(i) = \Sigma_{i | d}\mu(\frac{d}{i}) *  \lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor$\\
于是$ans = \Sigma_i^{min(n, m)}F(i) * g(i)$\\
展开化简得到$\Sigma_d^{min(n, m)} \lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor\Sigma_{i | d}F(i)\mu(\frac{d}{i})$\\
然后对$\Sigma_{i | d}F(i)\mu(\frac{d}{i})$求个前缀和\\
枚举每个i更新i的倍数即可\\
现在考虑将a离线处理，询问按a排序\\
用树状数组维护前缀和即可。\\
\begin{lstlisting}
#include <cstdio>
#include <algorithm>
using namespace std;
typedef pair<int, int> P;
const int MAXN = 100003;
int prime[MAXN], cnt, mu[MAXN], mnsum[MAXN], a[MAXN];
bool isp[MAXN];
P f[MAXN];
void Euler(int n) {
    mu[1] = 1;
    f[1] = P(1, 1);
    for(int i = 2; i <= n; i++) {
        f[i].second = i;
        if(!isp[i]) {
            prime[++cnt] = a[i] = i;
            mu[i] = -1;
            f[i].first = mnsum[i] = i + 1;
        }
        for(int j = 1; j <= cnt && i * prime[j] <= n; j++) {
            isp[i * prime[j]] = 1;
            if(i % prime[j] == 0) {
                mu[i * prime[j]] = 0;
                mnsum[i * prime[j]] = mnsum[i] + a[i] * prime[j];
                f[i * prime[j]].first = f[i].first / mnsum[i] * mnsum[i * prime[j]];
                a[i * prime[j]] = a[i] * prime[j];
                break;
            }
            mu[i * prime[j]] = -mu[i];
            f[i * prime[j]].first = f[i].first * (prime[j] + 1);
            a[i * prime[j]] = prime[j];
            mnsum[i * prime[j]] = prime[j] + 1;
        }
    }
}
int bit[MAXN];
void add(int x, int v) {
    for(; x <= 100000; x += x & -x) bit[x] += v;
}
int sum(int x) {
    int res = 0;
    for(; x; x -= x & -x) res += bit[x];
    return res;
}
struct Node {
    int n, m, a, id;
    bool operator < (const Node &x) const {
        return a < x.a;
    }
    inline void read(int i) {
        id = i; scanf("%d%d%d", &n, &m, &a);
    }
}q[MAXN];
int ans[MAXN];
int cal(int n, int m) {
    if(n > m) swap(n, m);
    int res = 0, last;
    for(int i = 1; i <= n; i = last + 1) {
        last = min(n / (n / i), m / (m / i));
        res += (n / i) * (m / i) * (sum(last) - sum(i - 1));
    }
    return res & 0x7fffffff;
}
int main() {
    Euler(100000);
    sort(f + 1, f + 100001);
    int T;
    scanf("%d", &T);
    for(int i = 1; i <= T; i++) q[i].read(i);
    sort(q + 1, q + T + 1);
    int cur = 1, N, M, A;
    for(int Q = 1; Q <= T; Q++) {
        N = q[Q].n, M = q[Q].m, A = q[Q].a;
        while(cur <= 100000 && f[cur].first <= A) {
            for(int i = f[cur].second; i <= 100000; i += f[cur].second)
                add(i, f[cur].first * mu[i / f[cur].second]);
            cur++;
        }
        ans[q[Q].id] = cal(N, M);
    }
    for(int i = 1; i <= T; i++) printf("%d\n", ans[i]);
    return 0;
}
\end{lstlisting}

题目大意：求$\Sigma_i^n\Sigma_j^mlcm(i, j) mod 20101009$\\

解：\\
这里跟之前的区别在于，gcd(i,j)在分母上，那么考虑反演\\
令$f(x) = \frac{1}{x}$\\
$F(x) = f $ X $\mu$ 这里X是Dirichlet积\\
即$F(x) = \Sigma_{d | x}f(d) * \mu(\frac{x}{d})$\\
那么由莫比乌斯反演我们有$f=F$X$1$\\
那么$\Sigma_i^n\Sigma_j^mlcm(i, j)$\\
=$\Sigma_i^n\Sigma_j^mi*j*f(gcd(i, j))$\\
=$\Sigma_i^n\Sigma_j^mi*j*\Sigma_{d|gcd(i, j)F(d)}$\\
另$sum(x, y) = \Sigma_i^x\Sigma_j^yi*j$\\
于是可以进一步化简$ans = \Sigma_d^nF(d) * d * d * sum(\frac{n}{d}, \frac{m}{d})$\\
\begin{lstlisting}
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 20101009, MAXN = 10000003;
int mu[MAXN], prime[MAXN], sum[MAXN];
int cnt;
bool isp[MAXN];
void getmu(int n) {
    mu[1] = 1;
    for(int i = 2; i <= n; i++) {
        if(!isp[i]) {
            mu[i] = -1;
            prime[++cnt] = i;
        }
        for(int j = 1; j <= cnt && i * prime[j] <= n; j++) {
            isp[i * prime[j]] = 1;
            if(i % prime[j] == 0) {
                mu[i * prime[j]] = 0;
                break;
            }
            mu[i * prime[j]] = -mu[i];
        }
    }
}
ll n, m, ans;
ll query(ll x, ll y) { return (x * (x + 1) / 2 % mod) * (y * (y + 1) / 2 % mod) % mod; }
ll F(ll x, ll y) {
    ll res = 0, last;
    for(ll i = 1; i <= min(x, y); i = last + 1) {
        last = min(x / (x / i), y / (y / i));
        res = (res + (sum[last] - sum[i - 1]) * query(x / i, y / i) % mod) % mod;
    }
    return res;
}
int main() {
    cin>>n>>m;
    getmu(min(n, m));
    for(ll i = 1; i <= min(n, m); i++) sum[i] = (sum[i - 1] + (i * i * mu[i]) % mod) % mod;
    ll last;
    for(ll d = 1; d <= min(n, m); d = last + 1) {
        last = min(n / (n / d), m / (m / d));
        ans = (ans + (last - d + 1) * (d + last) / 2 % mod * F(n / d, m / d) % mod) % mod;
    }
    ans = (ans + mod) % mod;
    cout<<ans<<endl;
    return 0;
}
\end{lstlisting}

总结一下：当推式子陷入僵局的时候，尝试将一些东西处理出来，通过分块、反演等方法降低复杂度。对于式子本身的特性进行观察，有时也可以发现优化的地方。\\
在推式子过程中，将有关变量放在一块处理是化简的常用技巧。\\

\subsection{Sieve}
Example: 51nod1239 欧拉函数之和\\
S(n) = Phi(1) + Phi(2) + ...... Phi(n)，给出n，求S(n)%1e9+7\\
\begin{lstlisting}
//杜教筛
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int MAXN = 1e7 + 5, mod = 1000000007;
vector<int> prime;
int phi[MAXN], P[MAXN];
bool isp[MAXN];
unordered_map<LL, int> mp;
void Euler(int n) {
    phi[1] = 1;
    for(int i = 2; i <= n; i++) {
        if(!isp[i]) {
            prime.push_back(i);
            phi[i] = i - 1;
        }
        for(auto x : prime) {
            if(i * x > n) break;
            isp[i * x] = 1;
            if(i % x == 0) {
                phi[i * x] = phi[i] * x;
                break;
            }
            phi[i * x] = phi[i] * (x - 1);
        }
    }
    for(int i = 1; i <= n; i++) P[i] = (P[i - 1] + phi[i]) % mod;
}
LL cal(LL n) {
    if(n < MAXN) return P[n];
    if(mp.count(n)) return mp[n];
    LL res = 0;
    for(LL i = 2, last; i <= n; i = last + 1) {
        last = n / (n / i);
        res += (last - i + 1) % mod * cal(n / i) % mod;
        res %= mod;
    }
    mp[n] = res = ((__int128)n * (n + 1) / 2 % mod + mod - res) % mod;
    return res;
}
int main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.precision(6); cout << fixed;
    Euler(MAXN - 1);
    LL n; cin >> n;
    cout << cal(n) << endl;
    return 0;
}
//min25
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int MAXN = 1e6 + 5, mod = 1e9 + 7;
const int inv2 = (mod + 1) / 2, inv6 = (mod + 1) / 6;
int prime[MAXN], isp[MAXN], cnt;
LL g[3][MAXN << 1], h[3][MAXN << 1];
LL w[MAXN << 1];
int id1[MAXN], id2[MAXN];
inline int MOD(LL x) { return x >= mod ? x - mod : x; }
//inline int MOD(LL x) { return x % mod; }
inline int add(LL x, LL y) { return MOD(MOD(x) + MOD(y)); }
void Euler(int n) {
    for(int i = 2; i <= n; i++) {
        if(!isp[i]) {
            prime[++cnt] = i;
            h[0][cnt] = h[0][cnt - 1] + 1;
            h[1][cnt] = add(h[1][cnt - 1], i);
            h[2][cnt] = add(h[2][cnt - 1], (LL)i * i % mod);
        }
        for(int j = 1; j <= cnt && i * prime[j] <= n; j++) {
            isp[i * prime[j]] = 1;
            if(i % prime[j] == 0) {
                break;
            }
        }
    }
}
LL n;
int sz, m;
inline int id(LL x) {
    return x <= sz ? id1[x] : id2[n / x];
}
//f(p ^ k)
inline int f(int p, LL pk) {
    return pk / p * (p - 1) % mod;
}
LL S(LL x, int y) {
    if(x <= 1 || prime[y] > x) return 0;
    //g(x) - h(j - 1)
    LL res = add(add(g[1][id(x)], mod - g[0][id(x)]), mod - add(h[1][y - 1], mod - h[0][y - 1]));
    for(int j = y, k = 1; j <= cnt && (LL)prime[j] * prime[j] <= x; j++, k = 1) {
        for(LL pk = prime[j]; pk * prime[j] <= x; pk *= prime[j], k++) {
            res = add(res, S(x / pk, j + 1) * f(prime[j], pk) % mod + f(prime[j], pk * prime[j]));
        }
    }
    return res;
}
int main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.precision(6); cout << fixed;
    cin >> n; 
    sz = sqrt(n) + 1;
    Euler(sz);
    for(LL i = 1, last, t; i <= n; i = last + 1) {
        last = n / (n / i);
        w[++m] = n / i, t = n / i % mod;
        w[m] <= sz ? id1[w[m]] = m : id2[last] = m;
        g[0][m] = MOD(t + mod - 1);
        g[1][m] = add(t * (t + 1) % mod * inv2 % mod, mod - 1);
        g[2][m] = add((2 * t + 1) % mod * t * (t + 1) % mod * inv6 % mod, mod - 1);
    }
    for(int j = 1; j <= cnt; j++) {
        for(int i = 1; i <= m && (LL)prime[j] * prime[j] <= w[i]; i++) {
            g[0][i] = MOD(g[0][i] + mod - (g[0][id(w[i] / prime[j])] - h[0][j - 1]));
            g[1][i] = MOD(g[1][i] + mod - ((LL)prime[j] * MOD(g[1][id(w[i] / prime[j])] + mod - h[1][j - 1]) % mod));
            g[2][i] = MOD(g[2][i] + mod - ((LL)prime[j] * prime[j] % mod * MOD(g[2][id(w[i] / prime[j])] + mod - h[2][j - 1]) % mod));
        }
    }
    //S(n, 1) + F(1);
    LL ans = MOD(S(n, 1) + 1);
    cout << ans << endl;
    return 0;
}
\end{lstlisting}

Example: 51nod1224 莫比乌斯函数之和\\
S(a,b) = miu(a) + miu(a + 1) + ...... miu(b)\\
\begin{lstlisting}
//杜教筛
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int MAXN = 3e7 + 5;
vector<int> prime;
int mu[MAXN];
int M[MAXN];
bool isp[MAXN];
unordered_map<LL, LL> mp;
void Euler(int n) {
    mu[1] = 1;
    for(int i = 2; i <= n; i++) {
        if(!isp[i]) {
            prime.push_back(i);
            mu[i] = -1;
        }
        for(auto x : prime) {
            if(i * x > n) break;
            isp[i * x] = 1;
            if(i % x == 0) {
                mu[i * x] = 0;
                break;
            }
            mu[i * x] = -mu[i];
        }
    }
    for(int i = 1; i <= n; i++) M[i] = M[i - 1] + mu[i];
}
LL cal(LL n) {
    if(n < MAXN) return M[n];
    if(mp.count(n)) return mp[n];
    LL res = 0;
    for(LL i = 2, last; i <= n; i = last + 1) {
        last = n / (n / i);
        res += (last - i + 1) * cal(n / i);
    }
    mp[n] = 1 - res;
    return 1 - res;
}
int main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.precision(6); cout << fixed;
    Euler(MAXN - 1);
    LL a, b;
    cin >> a >> b;
    cout << cal(b) - cal(a - 1) << endl;
    return 0;
}
//min25
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int MAXN = 1e6 + 5;
int prime[MAXN], isp[MAXN], cnt;
LL g[3][MAXN << 1], h[3][MAXN << 1];
LL w[MAXN << 1];
int id1[MAXN], id2[MAXN];
void Euler(int n) {
    for(int i = 2; i <= n; i++) {
        if(!isp[i]) {
            prime[++cnt] = i;
            h[0][cnt] = h[0][cnt - 1] + 1;
        }
        for(int j = 1; j <= cnt && i * prime[j] <= n; j++) {
            isp[i * prime[j]] = 1;
            if(i % prime[j] == 0) {
                break;
            }
        }
    }
}
LL a, b;
LL n;
int sz, m;
inline int id(LL x) {
    return x <= sz ? id1[x] : id2[n / x];
}
//f(p ^ k)
inline int f(int p, int k) {
    return k == 1 ? -1 : 0;
}
LL S(LL x, int y) {
    if(x <= 1 || prime[y] > x) return 0;
    //g(x) - h(j - 1)
    LL res = - g[0][id(x)] + h[0][y - 1];
    for(int j = y, k = 1; j <= cnt && (LL)prime[j] * prime[j] <= x; j++, k = 1) {
        for(LL pk = prime[j]; pk * prime[j] <= x; pk *= prime[j], k++) {
            res += S(x / pk, j + 1) * f(prime[j], k) + f(prime[j], k + 1);
        }
    }
    return res;
}
LL cal(LL x) {
    n = x;
    m = 0;
    sz = sqrt(n);
    for(LL i = 1, last, t; i <= n; i = last + 1) {
        last = n / (n / i);
        w[++m] = n / i, t = n / i;
        w[m] <= sz ? id1[w[m]] = m : id2[last] = m;
        g[0][m] = t - 1;
    }
    for(int j = 1; j <= cnt; j++) {
        for(int i = 1; i <= m && (LL)prime[j] * prime[j] <= w[i]; i++) {
            g[0][i] = g[0][i] - (g[0][id(w[i] / prime[j])] - h[0][j - 1]);
        }
    }
    return S(x, 1) + 1;
} 
int main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.precision(6); cout << fixed;
    cin >> a >> b; 
    Euler(sqrt(b));

    //S(n, 1) + F(1);
    cout << cal(b) - cal(a - 1) << endl;
    return 0;
}
\end{lstlisting}

\newpage
\section{Geometry}
尚未开始


\newpage
\section{Game Theory}
\subsection{Bash's Game}
Bash's Game巴什博弈\\
有一堆个数为n的石子，游戏双方依次从中拿取，满足:\\
1.每次至少取1个，最多取m个.\\
最后取光者得胜。\\
结论: n = t(m+1) + r, 必败态:r = 0;\\
巴什博弈变种:\\
取一个指定集合的石头个数\\
取到最后一个石子输, n = t(m + 1)  + r, r = 1;\\
\subsection{Wythoff’s Game}
Wythoff’s Game（威佐夫博弈）\\
有两堆分别为(an, bn)的石子,游戏双方依次从中拿取，满足:\\
1.从任意一堆中取任意个 > 1。 
2.从两堆中取同样多个。
最后取完者胜.\\
结论: 对于任意的局势(a, b)(a < b),必败点为 (b-a)*(sqrt(5)+1)/2=a. \\
\subsection{Fibonacci’s Game / Zeckendorf's theory}
Fibonacci’s Game（斐波那契博弈）\\
有一堆个数为 n 的石子，游戏双方轮流取石子，满足：\\
1. 先手不能在第一次把所有的石子取完；\\
2. 之后每次可以取的石子数介于1到对手刚取的石子数的2倍之间（包含1和对手刚取的石子数的2倍）。\\
结论:必败点是斐波那契数\\
\par
齐肯多夫定理:任何正整数可以表示为若干个不连续的Fibonacci数之和\\
\subsection{Nim’s Game / Anti-Nim's Game / K-Nim's Game / Anti-K-Nim's Game}
Nim’s Game（尼姆博弈）\\
石子的个数可以等价成某个游戏的SG函数。\\
\par
有n堆石子，游戏双方依次从中拿取, 满足:\\
1.规定每次只能从一堆中取若干根， 可将一堆全取走，但不可不取.\\
最后取完者为胜。\\
结论:\\
T态:所有火柴数异或和为0\\
S态:所有火柴数异或和不为0\\
必胜态:S\\
\par
有n堆石子,游戏双方依次从中拿取,满足:\\
1.规定每次只能从一堆中取若干根， 可将一堆全取走，但不可不取.\\
最后取完者为败。\\
结论:\\
S0态:即仅有奇数个孤单堆\\
T0态:即仅有偶数个孤单堆\\
S1态:异或和大于0,且有1个充裕堆\\
T1态:不存在\\
S2态:异或和大于0,且有多个充裕堆\\
T2态:异或和等于0,且有多个充裕堆\\
必胜态:T0,S1,S2\\
必败态:S0,T2\\
\par
有n堆石子，游戏双方依次从中拿取, 满足:\\
1.规定每次只能至多k堆中取若干根， 可将k堆全取走，但不可不取.\\
最后取完者为胜。\\
结论:\\
对于每一堆，把它石子的个数用二进制表示\\
必败态:对所有的石子堆，如果在任何一个二进制位上1的个数总是k+1的整数倍\\
\par
有n堆石子，游戏双方依次从中拿取, 满足:\\
1.规定每次只能至多k堆中取若干根， 可将k堆全取走，但不可不取\\
最后取完者为败。\\
结论:\\
1.对于每一堆，把它石子的个数用二进制表示\\
2.所有的堆（非零堆，下同）全是1,此时如果1堆个数模k+1的结果是1则必败，否则必胜(我们可以通过 拿走0到k个堆来随意调整当前状态模的结果，然后再将所有大于1的堆降到1就行了)\\
3.有多于k个堆的个数大于1。必胜\\
\subsection{阶梯博弈}
有n个阶梯呈升序排列，每个阶梯上有若干个石子，游戏双方轮流取石子,满足:\\
1.将一个阶梯上的石子移任意个（>0）到前一个台阶。\\
当没有可行操作时（所有石子都被移动到了地面，即第0号台阶）输。\\
结论:\\
奇数号台阶的Nim游戏\\
变种1:
树上,每个石子只能往父亲节点移动.\\
变种2:\\
游戏双方在一个1*N的格子内挪动棋子，刚开始在若干个位置上有棋子,每个位置至多一个棋子\\
每一个选手可以进行的操作时选择一个棋子并把它向左方移动，当然不能越过其它的棋子，也不能超出边界。\\
谁不能移动谁就输了。求谁会赢？\\
结论:\\
将棋子位置按升序排列,然后从后往前两两绑成一对,如果个数是奇数,那么将第一个和边界外绑定.\\
一对棋子的前一个和前一对棋子的后一个之间有多少个空位置对最终的结果是没有影响的。\\
于是我们只需要考虑同一对的两个棋子之间有多少空位,将同一对棋子间的空位视为石子,做nim游戏\\
两对棋子间的空格数当奇数位石子,其他当偶数位石子,石子相右边移动\\
变种3:\\
山上有ｎ个人，每个人给出距离山顶的距离，给出其中一个人为king，每次能挑选一个人向上移动，不能越过其他人，最后将king移动到山顶者获胜。问获胜者。\\
结论:\\
只要把King当作普通人一样处理即可。除了两种特殊情况：\\
1. 当King是第一个人时，Alice直接胜\\
2. 当King是第二个人且一共有奇数个人时，第一堆的大小需要减1。\\
\subsection{Multi-Nim}
有n堆石子，游戏双方依次从中拿取, 满足:\\
1.任意一堆石子中拿任意多个石子(不能不拿)\\
2.把一堆数量不少于2石子分为两堆不为空的石子\\
最后取完者为胜。\\
结论:\\
操作一与普通的Nim游戏等价\\
操作二实际上是将一个游戏分解为两个游戏，根据SG定理，我们可以通过异或运算把两个游戏连接到一起，作为一个后继状态\\
\begin{equation}
    SG(x)\equiv\left\{
    \begin{aligned}
    &x-1 & & (x mod 4 = 0) \\
    &x   & & (x mod 4 = 1 or 2)  \\
    &x+1 & & (x mod 4 = 3)
    \end{aligned}
    \right.
\end{equation}
\par
Multi-SG 游戏规定，在符合拓扑原则的前提下，一个单一游戏的后继可以为多个单一游戏。\\
Multi-SG其他规则与SG游戏相同。\\
注意在这里要分清楚后继与多个单一游戏\\
对于一个状态来说，不同的划分方法会产生多个不同的后继，而在一个后继中可能含有多个独立的游戏\\
一个后继状态的SG值即为后继状态中独立游戏的异或和\\
该状态的SG值即为后继状态的SG值中未出现过的最小值\\
\subsection{Every-SG}
给定一张无向图，上面有一些棋子，两个顶尖聪明的人在做游戏，每人每次必须将可以移动的棋子进行移动，不能移动的人\\
因为两个人都顶尖聪明，因此当一个人知道某一个游戏一定会输的话，它一定会尽力缩短游戏的时间，当它知道某一个游戏一定会赢的话，一定会尽力延长游戏的时间\\
对于还没有结束的单一游戏，游戏者必须对该游戏进行一步决策；\\
其他规则与普通SG游戏相同\\
Every-SG游戏与普通SG游戏最大的不同就是它多了一维时间\\
对于SG值为0的点，我们需要知道最少需要多少步才能走到结束\\
对于SG值不为0的点，我们需要知道最多需要多少步结束\\
这样我们用step变量来记录这个步数\\
\begin{equation}
    step(x)\equiv\left\{
    \begin{aligned}
    &0            & & u为终止状态 \\
    &max{step(v)} & & sg(u)!=0∧v为u的后继∧sg(v)=0\\
    &min{step(v)} & & sg(u)=0∧v为u的后继
    \end{aligned}
    \right.
\end{equation}
\subsection{树的删边游戏}
给出一个有 N个点的树，有一个点作为树的根节点。游戏者轮流从树中删去边，删去一条边后，不与根节点相连的部分将被移走。谁无法移动谁输。\\
结论:\\
Colon Principle:对于树上的某一个点，ta的分支可以转化成以这个点为根的一根竹子，这个竹子的长度就是ta各个分支的边的数量的异或和\\
叶子节点的SG值为0；中间节点的SG值为它的所有子节点的SG值加1后的异或和。\\

\subsection{Chomp's theory?}
取一个无关紧要的位置,如果对方必胜,则学习其策略,我方必胜.
\subsection{Other's theory?}
有n堆石子，游戏双方依次从中拿取, 满足:\\
1.规定每次能从任意多堆中取1根,不可不取.\\
最后取完者为胜。\\
结论:如果全是偶数,先手必败,否者先手必胜\\
\par
一个无相联通图，有一个点作为图的根。\\
游戏者轮流从图中删去边，删去一条边后，不与根节点相连的部分将被移走。\\
谁无路可走谁输。\\
结论:\\
Fusion Principle:环上的点可以融合，且不改变图的SG值,我们可以把一个带有奇数边的环等价成只有一个端点的一条边 而偶数边的环等价于一个点\\
\subsection{SG Theory}
\begin{lstlisting}
memset(mex, 0, sizeof mex);
for (int i = 1; i < maxN;++i) {
    for (int j = 1; j <= n;++j) {
        if (a[j] <= i)
            mex[SG[i - a[j]]] = i;
            for (int k = 1; i - k - a[j] > 0;++k)
                mex[SG[k] ^ SG[i - k - a[j]]] = 1;
    }
    for (int j = 0;; ++j)
        if (mex[j]!=i){
            SG[i] = j;
            break;
        }
}
\end{lstlisting}
\subsection{SJ Theory}
反公平游戏 Anti-SG Game\\
DAG上没有出度的点为胜利状态，其它定义与一般游戏相同。\\
现在的问题是解决多个反公平游戏的合并。\\
SJ定理说明：先手必胜，当且仅当以下两个条件同时成立或同时不成立：\\
1.合并的SG值为0；\\
2.所有游戏的SG值不超过1。\\
\subsection{Surreal Number Theory}


\newpage
\section{DP}
\subsection{最大子矩阵}
单调栈法：
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1007;
int a[MAXN][MAXN], b[MAXN][MAXN];
pair<int, int> mp[MAXN * MAXN];
pair<int, int> off[MAXN][MAXN];
int tail;
pair<int, int> st[MAXN];
int Up[MAXN][MAXN];
int ans = 0;
void maintain(pair<int, int> v) {
    for(;tail && st[tail].first >= v.first; tail--) {
        ans = max(ans, st[tail].first * (v.second - st[tail-1].second-1));
    }
}
void clear(int pos) {
    for(;tail; tail--)
        ans = max(ans, st[tail].first * (pos -st[tail-1].second-1));
}
int main() {
    ios::sync_with_stdio(0); cin.tie(0);
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++) {
            cin >> a[i][j];
            mp[a[i][j]] = {i,j};
        }
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++) {
            cin >> b[i][j];
            off[i][j] = {i - mp[b[i][j]].first, j - mp[b[i][j]].second};

        }
    for(int i = 1; i <= n; i++) {
        st[0].second = 0;
        for(int j = 1; j <= m; j++) {
            Up[i][j] = i > 1 && off[i][j] == off[i-1][j] ? Up[i-1][j] + 1 : 1;
            if(j > 1 && off[i][j] == off[i][j-1]) 
                maintain({Up[i][j], j}); else {clear(j); st[0].second = j-1;}
            st[++tail] = {Up[i][j], j};
        }
        clear(m+1);
    }
    cout << ans << endl;
    return 0;
}
\end{lstlisting}
悬线法：
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1007;
int a[MAXN][MAXN], b[MAXN][MAXN];
pair<int, int> mp[MAXN * MAXN];
pair<int, int> off[MAXN][MAXN];
int L[MAXN][MAXN], R[MAXN][MAXN], UP[MAXN][MAXN];
int main() {
    ios::sync_with_stdio(0); cin.tie(0);
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++) {
            cin >> a[i][j];
            mp[a[i][j]] = {i,j};
        }
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++) {
            cin >> b[i][j];
            off[i][j] = {i - mp[b[i][j]].first, j - mp[b[i][j]].second};
            L[i][j] = R[i][j] = j;
            UP[i][j] = 1;
        }
    for(int i = 1; i <= n; i++) 
        for(int j = 2; j <= m; j++) {
            if(off[i][j] == off[i][j-1]) L[i][j] = L[i][j-1];
        }
    for(int i = 1; i <= n; i++) 
        for(int j = m - 1; j >= 1; j--) {
            if(off[i][j] == off[i][j+1]) R[i][j] = R[i][j+1];
        }
    int ans = 0;
    for(int i = 1; i <= n; i++) 
        for(int j = 1; j <= m; j++) {
            if(i > 1 && off[i][j] == off[i-1][j]) {
                UP[i][j] = UP[i-1][j] + 1;
                L[i][j] = max(L[i][j], L[i-1][j]);
                R[i][j] = min(R[i][j], R[i-1][j]); 
            }
            ans = max(ans, (R[i][j] - L[i][j] + 1) * UP[i][j]);
        }
    cout << ans << endl;
    return 0;
}
\end{lstlisting}
\subsection{斜率优化}
\subsection{四边形不等式优化}
\subsection{忘情水二分}

\end{document}
